using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using DomainBridge.SourceGenerators.Models;
using DomainBridge.SourceGenerators.Services;

namespace DomainBridge.SourceGenerators
{
    [Generator]
    public class DomainBridgeGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            var compilation = context.Compilation;
            var analyzer = new TypeAnalyzer();
            var typesToProcess = new Queue<INamedTypeSymbol>();
            var processedTypes = new HashSet<string>();
            var typeModels = new List<TypeModel>();

            // Find types marked with [DomainBridge]
            foreach (var classDeclaration in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var symbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                
                if (symbol == null) continue;
                
                if (analyzer.HasDomainBridgeAttribute(symbol))
                {
                    typesToProcess.Enqueue(symbol);
                }
            }

            // Process types and their dependencies
            while (typesToProcess.Count > 0)
            {
                var typeSymbol = typesToProcess.Dequeue();
                var typeFullName = typeSymbol.ToDisplayString();
                
                if (processedTypes.Contains(typeFullName))
                    continue;
                
                processedTypes.Add(typeFullName);
                
                var typeModel = analyzer.AnalyzeType(typeSymbol);
                typeModels.Add(typeModel);
                
                // Find referenced types
                var referencedTypes = analyzer.GetReferencedTypes(typeModel);
                foreach (var referencedType in referencedTypes.OfType<INamedTypeSymbol>())
                {
                    if (!processedTypes.Contains(referencedType.ToDisplayString()))
                    {
                        typesToProcess.Enqueue(referencedType);
                    }
                }
            }

            // Generate code
            if (typeModels.Any())
            {
                var code = GenerateProxyCode(typeModels, processedTypes);
                context.AddSource("DomainBridge.Generated.cs", code);
            }
        }

        private string GenerateProxyCode(List<TypeModel> typeModels, HashSet<string> processedTypes)
        {
            var builder = new CodeBuilder();
            var typeNameResolver = new TypeNameResolver(processedTypes);
            var interfaceGenerator = new InterfaceGenerator(typeNameResolver);
            var proxyGenerator = new ProxyGenerator(typeNameResolver);

            // File header
            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using System.Collections.Concurrent;");
            builder.AppendLine("using System.Linq;");
            builder.AppendLine("using System.Runtime.Remoting.Lifetime;");
            builder.AppendLine();
            builder.AppendLine("namespace DomainBridge.Generated");
            builder.OpenBlock("");

            // Generate interfaces and proxies
            foreach (var typeModel in typeModels)
            {
                // Generate interface
                interfaceGenerator.Generate(builder, typeModel);
                builder.AppendLine();
                
                // Generate proxy
                proxyGenerator.Generate(builder, typeModel);
                builder.AppendLine();
            }

            builder.CloseBlock();
            
            return builder.ToString();
        }

        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                    classDeclaration.AttributeLists.Count > 0)
                {
                    CandidateClasses.Add(classDeclaration);
                }
            }
        }
    }
}