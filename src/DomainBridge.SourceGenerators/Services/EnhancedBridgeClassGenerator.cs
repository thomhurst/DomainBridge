using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using DomainBridge.SourceGenerators.Models;

namespace DomainBridge.SourceGenerators.Services
{
    /// <summary>
    /// Enhanced bridge class generator that handles automatic type resolution and wrapping
    /// </summary>
    internal sealed class EnhancedBridgeClassGenerator
    {
        private readonly BridgeTypeResolver _typeResolver;
        private readonly TypeAnalyzer _typeAnalyzer;
        private readonly MethodValidator _methodValidator;
        private GeneratorExecutionContext? _context;
        
        public EnhancedBridgeClassGenerator(BridgeTypeResolver typeResolver, TypeAnalyzer typeAnalyzer)
        {
            _typeResolver = typeResolver ?? throw new ArgumentNullException(nameof(typeResolver));
            _typeAnalyzer = typeAnalyzer ?? throw new ArgumentNullException(nameof(typeAnalyzer));
            _methodValidator = new MethodValidator();
        }
        
        public string GenerateBridgeClass(
            BridgeTypeInfo bridgeInfo,
            INamedTypeSymbol targetType,
            AttributeConfiguration? config = null,
            GeneratorExecutionContext? context = null)
        {
            _context = context;
            var typeModel = _typeAnalyzer.AnalyzeType(targetType);
            var builder = new CodeBuilder();
            
            GenerateFileHeader(builder);
            
            // Use the namespace from BridgeTypeInfo which handles both explicit and auto cases
            var namespaceToUse = bridgeInfo.BridgeNamespace;
            
            builder.AppendLine($"namespace {namespaceToUse}");
            builder.OpenBlock("");
            
            GenerateBridgeClass(builder, bridgeInfo, typeModel, targetType, config);
            
            builder.CloseBlock();
            
            return builder.ToString();
        }
        
        private void GenerateFileHeader(CodeBuilder builder)
        {
            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using System.Linq;");
            builder.AppendLine("using System.Collections.Concurrent;");
            builder.AppendLine("using DomainBridge;");
            builder.AppendLine("using DomainBridge.Runtime;");
            builder.AppendLine();
        }
        
        private void GenerateBridgeClass(
            CodeBuilder builder, 
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel,
            INamedTypeSymbol targetType,
            AttributeConfiguration? config)
        {
            // Check if the target type already inherits from MarshalByRefObject
            bool targetInheritsFromMarshalByRefObject = InheritsFromMarshalByRefObject(targetType);
            
            // Generate class declaration with generic type parameters if needed
            var className = bridgeInfo.BridgeClassName;
            var genericConstraints = new List<string>();
            
            // If the target type is generic, collect constraints
            if (targetType.IsGenericType)
            {
                // Collect constraints for each type parameter
                foreach (var typeParam in targetType.TypeParameters)
                {
                    var constraints = new List<string>();
                    
                    // Check for special constraints
                    if (typeParam.HasReferenceTypeConstraint)
                        constraints.Add("class");
                    else if (typeParam.HasValueTypeConstraint)
                        constraints.Add("struct");
                    
                    // Add base type constraints
                    foreach (var constraintType in typeParam.ConstraintTypes)
                    {
                        constraints.Add(_typeResolver.ResolveType(constraintType));
                    }
                    
                    // Check for constructor constraint
                    if (typeParam.HasConstructorConstraint && !typeParam.HasValueTypeConstraint)
                        constraints.Add("new()");
                    
                    if (constraints.Any())
                    {
                        genericConstraints.Add($"where {typeParam.Name} : {string.Join(", ", constraints)}");
                    }
                }
            }
            
            // Generate class declaration (className already contains generic parameters from BridgeTypeInfo)
            var classDeclaration = bridgeInfo.IsExplicitlyMarked
                ? $"public partial class {className}"
                : $"public sealed class {className}";
            
            // Inheritance strategy:
            // 1. If target inherits from MarshalByRefObject and is not sealed, inherit from target
            // 2. Otherwise, inherit from MarshalByRefObject directly
            if (targetInheritsFromMarshalByRefObject && !targetType.IsSealed)
            {
                // Inherit from target type which already has MarshalByRefObject
                classDeclaration += $" : {targetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}";
            }
            else
            {
                // Inherit from MarshalByRefObject directly
                classDeclaration += " : global::System.MarshalByRefObject";
            }
            
            // Always add IDisposable
            classDeclaration += ", global::System.IDisposable";
                
            // Add interfaces (excluding IDisposable since we already added it)
            if (typeModel.Interfaces.Any())
            {
                var interfaceList = string.Join(", ", typeModel.Interfaces
                    .Where(i => i.Name != "IDisposable" || i.ContainingNamespace?.ToDisplayString() != "System")
                    .Select(i => _typeResolver.ResolveType(i)));
                if (!string.IsNullOrEmpty(interfaceList))
                {
                    classDeclaration += $", {interfaceList}";
                }
            }
            
            // Add generic constraints to the class declaration
            if (genericConstraints.Any())
            {
                classDeclaration += " " + string.Join(" ", genericConstraints);
            }
            
            builder.OpenBlock(classDeclaration);
            
            GenerateFields(builder);
            GenerateConstructors(builder, bridgeInfo, typeModel, config);
            GenerateCreateMethods(builder, bridgeInfo, typeModel);
            GenerateStaticInstanceProperty(builder, bridgeInfo, typeModel);
            GenerateWrappedInstanceAccessor(builder, typeModel);
            GenerateMembers(builder, typeModel);
            GenerateHelperMethods(builder);
            GenerateDisposalImplementation(builder, bridgeInfo, typeModel);
            
            builder.CloseBlock();
        }
        
        private void GenerateFields(CodeBuilder builder)
        {
            builder.AppendLine("private readonly global::System.AppDomain _appDomain;");
            builder.AppendLine("internal readonly dynamic _instance;");
            builder.AppendLine("private bool _disposed;");
            builder.AppendLine();
        }
        
        private void GenerateConstructors(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel,
            AttributeConfiguration? config = null)
        {
            // Private constructor that takes instance and AppDomain
            // Extract just the class name without generic parameters for the constructor
            var constructorName = bridgeInfo.BridgeClassName;
            var genericBracketIndex = constructorName.IndexOf('<');
            if (genericBracketIndex > 0)
            {
                constructorName = constructorName.Substring(0, genericBracketIndex);
            }
            
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Internal constructor for wrapping an existing instance of {typeModel.FullName}");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock($"private {constructorName}(dynamic instance, global::System.AppDomain appDomain)");
            builder.AppendLine("_instance = instance ?? throw new global::System.ArgumentNullException(nameof(instance));");
            builder.AppendLine("_appDomain = appDomain ?? throw new global::System.ArgumentNullException(nameof(appDomain));");
            builder.CloseBlock();
            builder.AppendLine();
            
            // Internal GetOrCreate method for auto-generated bridges that need wrapping
            if (!bridgeInfo.IsExplicitlyMarked)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Gets or creates a bridge for the given instance in the current AppDomain");
                builder.AppendLine("/// </summary>");
                builder.OpenBlock($"internal static {bridgeInfo.BridgeClassName} GetOrCreate(dynamic instance)");
                builder.AppendLine("if (instance == null) return null!;");
                builder.AppendLine($"// For auto-generated bridges, we create in the current AppDomain");
                builder.AppendLine($"return new {constructorName}(instance, global::System.AppDomain.CurrentDomain);");
                builder.CloseBlock();
                builder.AppendLine();
            }
        }
        
        private void GenerateCreateMethods(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel)
        {
            // Generate Create methods only for explicitly marked types
            if (bridgeInfo.IsExplicitlyMarked)
            {
                // Extract just the class name without generic parameters for the constructor
                var constructorName = bridgeInfo.BridgeClassName;
                var genericBracketIndex = constructorName.IndexOf('<');
                if (genericBracketIndex > 0)
                {
                    constructorName = constructorName.Substring(0, genericBracketIndex);
                }
                // Generate Create method with factory
                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Creates a new isolated instance of {typeModel.Symbol.Name} in a separate AppDomain");
                builder.AppendLine("/// </summary>");
                builder.AppendLine("/// <param name=\"factory\">Factory function to create the target instance in the isolated AppDomain</param>");
                builder.AppendLine("/// <param name=\"config\">Optional AppDomain configuration</param>");
                builder.AppendLine("/// <returns>A bridge instance that must be disposed when no longer needed</returns>");
                // For generic types, we need to use the closed generic type in the factory signature
                var factoryReturnType = typeModel.FullName;
                if (typeModel.Symbol.IsGenericType && typeModel.Symbol.IsUnboundGenericType)
                {
                    // This is an open generic type like GenericService<>
                    // We need to construct the closed type using the bridge's type parameters
                    var typeNameWithoutArity = typeModel.Symbol.Name;
                    var arityIndex = typeNameWithoutArity.IndexOf('`');
                    if (arityIndex > 0)
                    {
                        typeNameWithoutArity = typeNameWithoutArity.Substring(0, arityIndex);
                    }
                    
                    var typeParams = string.Join(", ", typeModel.Symbol.TypeParameters.Select(tp => tp.Name));
                    var containingNamespace = typeModel.Symbol.ContainingNamespace?.IsGlobalNamespace == true
                        ? ""
                        : typeModel.Symbol.ContainingNamespace?.ToDisplayString() ?? "";
                    
                    // Handle nested types
                    var containingTypes = new List<string>();
                    var current = typeModel.Symbol.ContainingType;
                    while (current != null)
                    {
                        containingTypes.Insert(0, current.Name);
                        current = current.ContainingType;
                    }
                    
                    if (containingTypes.Any())
                    {
                        var fullTypeName = string.Join(".", containingTypes) + "." + typeNameWithoutArity;
                        factoryReturnType = string.IsNullOrEmpty(containingNamespace)
                            ? $"{fullTypeName}<{typeParams}>"
                            : $"{containingNamespace}.{fullTypeName}<{typeParams}>";
                    }
                    else
                    {
                        factoryReturnType = string.IsNullOrEmpty(containingNamespace)
                            ? $"{typeNameWithoutArity}<{typeParams}>"
                            : $"{containingNamespace}.{typeNameWithoutArity}<{typeParams}>";
                    }
                }
                
                builder.OpenBlock($"public static {bridgeInfo.BridgeClassName} Create(global::System.Func<{factoryReturnType}> factory, global::DomainBridge.DomainConfiguration? config = null)");
                builder.AppendLine("if (factory == null) throw new global::System.ArgumentNullException(nameof(factory));");
                builder.AppendLine();
                builder.AppendLine("// Create configuration");
                builder.AppendLine("config = config ?? new global::DomainBridge.DomainConfiguration();");
                builder.AppendLine($"config.TargetAssembly = config.TargetAssembly ?? typeof({factoryReturnType}).Assembly.FullName;");
                builder.AppendLine();
                builder.AppendLine("// Create AppDomain");
                builder.AppendLine("var setup = new global::System.AppDomainSetup");
                builder.AppendLine("{");
                builder.AppendLine("    ApplicationBase = config.ApplicationBase ?? global::System.AppDomain.CurrentDomain.BaseDirectory,");
                builder.AppendLine("    PrivateBinPath = config.PrivateBinPath,");
                builder.AppendLine("    ConfigurationFile = config.ConfigurationFile");
                builder.AppendLine("};");
                builder.AppendLine();
                builder.AppendLine("if (config.EnableShadowCopy)");
                builder.AppendLine("{");
                builder.AppendLine("    setup.ShadowCopyFiles = \"true\";");
                builder.AppendLine("    setup.ShadowCopyDirectories = setup.ApplicationBase;");
                builder.AppendLine("}");
                builder.AppendLine();
                builder.AppendLine($"var domainName = $\"{bridgeInfo.BridgeClassName}_{{System.Guid.NewGuid():N}}\";");
                builder.AppendLine("var appDomain = global::System.AppDomain.CreateDomain(domainName, null, setup);");
                builder.AppendLine();
                builder.AppendLine("try");
                builder.AppendLine("{");
                builder.AppendLine("    // Create a proxy factory in the isolated domain");
                builder.AppendLine("    var proxyFactoryType = typeof(global::DomainBridge.Runtime.ProxyFactory);");
                builder.AppendLine("    var proxyFactory = (global::DomainBridge.Runtime.ProxyFactory)appDomain.CreateInstanceAndUnwrap(");
                builder.AppendLine("        proxyFactoryType.Assembly.FullName,");
                builder.AppendLine("        proxyFactoryType.FullName);");
                builder.AppendLine();
                builder.AppendLine("    // Configure the proxy factory with assembly resolver if needed");
                builder.AppendLine("    if (!string.IsNullOrEmpty(config.AssemblySearchPaths))");
                builder.AppendLine("    {");
                builder.AppendLine("        proxyFactory.ConfigureAssemblyResolver(config.AssemblySearchPaths.Split(';'));");
                builder.AppendLine("    }");
                builder.AppendLine();
                builder.AppendLine("    // Create the target instance in the isolated domain using the factory");
                builder.AppendLine($"    var targetInstance = proxyFactory.CreateInstance<{factoryReturnType}>(factory);");
                builder.AppendLine();
                builder.AppendLine($"    // Create and return the bridge");
                builder.AppendLine($"    return new {constructorName}(targetInstance, appDomain);");
                builder.AppendLine("}");
                builder.AppendLine("catch");
                builder.AppendLine("{");
                builder.AppendLine("    // If creation fails, unload the domain");
                builder.AppendLine("    try { global::System.AppDomain.Unload(appDomain); } catch { }");
                builder.AppendLine("    throw;");
                builder.AppendLine("}");
                builder.CloseBlock();
                builder.AppendLine();
                
                // Check if type has parameterless constructor
                var hasParameterlessConstructor = typeModel.Symbol.InstanceConstructors
                    .Any(c => c.Parameters.Length == 0 && c.DeclaredAccessibility == Microsoft.CodeAnalysis.Accessibility.Public);
                
                if (hasParameterlessConstructor)
                {
                    builder.AppendLine("/// <summary>");
                    builder.AppendLine($"/// Creates a new isolated instance of {typeModel.Symbol.Name} in a separate AppDomain using the default constructor");
                    builder.AppendLine("/// </summary>");
                    builder.AppendLine("/// <param name=\"config\">Optional AppDomain configuration</param>");
                    builder.AppendLine("/// <returns>A bridge instance that must be disposed when no longer needed</returns>");
                    builder.OpenBlock($"public static {bridgeInfo.BridgeClassName} Create(global::DomainBridge.DomainConfiguration? config = null)");
                    builder.AppendLine($"return Create(() => new {factoryReturnType}(), config);");
                    builder.CloseBlock();
                    builder.AppendLine();
                }
            }
        }
        
        private void GenerateMembers(CodeBuilder builder, TypeModel typeModel)
        {
            // Generate properties
            foreach (var property in typeModel.Properties.Where(p => !p.IsIgnored))
            {
                GenerateProperty(builder, property);
            }
            
            // Generate methods
            foreach (var method in typeModel.Methods.Where(m => !m.IsIgnored))
            {
                GenerateMethod(builder, method);
            }
            
            // Generate events
            foreach (var evt in typeModel.Events.Where(e => !e.IsIgnored))
            {
                GenerateEvent(builder, evt);
            }
        }
        
        private void GenerateProperty(CodeBuilder builder, PropertyModel property)
        {
            var propertyType = _typeResolver.ResolveType(property.Type);
            
            // Validate property type for AppDomain compatibility
            if (_context.HasValue)
            {
                var location = Location.None;
                var diagnostics = _methodValidator.ValidatePropertyType(property.Type, location, $"Property '{property.Name}'");
                foreach (var diagnostic in diagnostics)
                {
                    _context.Value.ReportDiagnostic(diagnostic);
                }
            }
            
            // Check if this is an explicit interface implementation
            if (property.IsInterfaceMember && property.DeclaringInterface != null)
            {
                var interfaceType = _typeResolver.ResolveType(property.DeclaringInterface);
                // Handle indexers differently
                if (property.IsIndexer)
                {
                    var parameters = GenerateParameterList(property.Parameters);
                    builder.OpenBlock($"{propertyType} {interfaceType}.this[{parameters}]");
                }
                else
                {
                    builder.OpenBlock($"{propertyType} {interfaceType}.{property.Name}");
                }
            }
            else
            {
                // Handle indexers differently
                if (property.IsIndexer)
                {
                    var parameters = GenerateParameterList(property.Parameters);
                    builder.OpenBlock($"public {propertyType} this[{parameters}]");
                }
                else
                {
                    builder.OpenBlock($"public {propertyType} {property.Name}");
                }
            }
            
            if (property.HasGetter)
            {
                builder.OpenBlock("get");
                builder.AppendLine("CheckDisposed();");
                
                // Generate the appropriate property/indexer access
                string instanceAccess;
                if (property.IsInterfaceMember && property.DeclaringInterface != null)
                {
                    // For explicit interface implementations, cast to interface type
                    var interfaceType = _typeResolver.ResolveType(property.DeclaringInterface);
                    if (property.IsIndexer)
                    {
                        var args = GenerateArgumentList(property.Parameters);
                        instanceAccess = $"(({interfaceType})_instance)[{args}]";
                    }
                    else
                    {
                        instanceAccess = $"(({interfaceType})_instance).{property.Name}";
                    }
                }
                else
                {
                    if (property.IsIndexer)
                    {
                        var args = GenerateArgumentList(property.Parameters);
                        instanceAccess = $"_instance[{args}]";
                    }
                    else
                    {
                        instanceAccess = $"_instance.{property.Name}";
                    }
                }
                
                // Check if property type is a dictionary with values that need wrapping
                if (IsDictionary(property.Type, out var keyType, out var valueType) && _typeResolver.NeedsWrapping(valueType))
                {
                    builder.AppendLine($"var value = {instanceAccess};");
                    builder.AppendLine("if (value == null) return null!;");
                    GenerateDictionaryReturn(builder, property.Type, keyType, valueType, "value");
                }
                // Check if property type is a collection with elements that need wrapping
                else if (IsCollection(property.Type, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    builder.AppendLine($"var value = {instanceAccess};");
                    builder.AppendLine("if (value == null) return null!;");
                    GenerateCollectionReturn(builder, property.Type, elementType, "value");
                }
                else if (_typeResolver.NeedsWrapping(property.Type))
                {
                    var bridgeInfo = GetBridgeInfo(property.Type);
                    builder.AppendLine($"var value = {instanceAccess};");
                    if (bridgeInfo.IsExplicitlyMarked)
                    {
                        // User-defined bridge - use Create with factory
                        builder.AppendLine($"return value != null ? global::{bridgeInfo.BridgeFullName}.Create(() => value) : null!;");
                    }
                    else
                    {
                        // Auto-generated bridge - use GetOrCreate
                        builder.AppendLine($"return value != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(value) : null!;");
                    }
                }
                else
                {
                    builder.AppendLine($"return {instanceAccess};");
                }
                
                builder.CloseBlock();
            }
            
            if (property.HasSetter)
            {
                builder.OpenBlock("set");
                builder.AppendLine("CheckDisposed();");
                
                // Generate the appropriate property/indexer assignment
                string instanceAssignment;
                if (property.IsInterfaceMember && property.DeclaringInterface != null)
                {
                    // For explicit interface implementations, cast to interface type
                    var interfaceType = _typeResolver.ResolveType(property.DeclaringInterface);
                    if (property.IsIndexer)
                    {
                        var args = GenerateArgumentList(property.Parameters);
                        instanceAssignment = $"(({interfaceType})_instance)[{args}]";
                    }
                    else
                    {
                        instanceAssignment = $"(({interfaceType})_instance).{property.Name}";
                    }
                }
                else
                {
                    if (property.IsIndexer)
                    {
                        var args = GenerateArgumentList(property.Parameters);
                        instanceAssignment = $"_instance[{args}]";
                    }
                    else
                    {
                        instanceAssignment = $"_instance.{property.Name}";
                    }
                }
                
                // Check if property type is a dictionary with values that need unwrapping
                if (IsDictionary(property.Type, out var keyType, out var valueType) && _typeResolver.NeedsWrapping(valueType))
                {
                    builder.AppendLine("if (value == null)");
                    builder.AppendLine("{");
                    builder.AppendLine($"    {instanceAssignment} = null;");
                    builder.AppendLine("}");
                    builder.AppendLine("else");
                    builder.AppendLine("{");
                    
                    // Convert bridge dictionary back to original type
                    var valueBridgeInfo = GetBridgeInfo(valueType);
                    var originalKeyType = keyType.ToDisplayString();
                    var originalValueType = valueType.ToDisplayString();
                    
                    // Ensure types are globally qualified (but not for built-in types)
                    if (!originalKeyType.StartsWith("global::") && !IsBuiltInType(originalKeyType))
                    {
                        originalKeyType = $"global::{originalKeyType}";
                    }
                    if (!originalValueType.StartsWith("global::") && !IsBuiltInType(originalValueType))
                    {
                        originalValueType = $"global::{originalValueType}";
                    }

                    builder.AppendLine($"    var result = new global::System.Collections.Generic.Dictionary<{originalKeyType}, {originalValueType}>();");
                    builder.AppendLine($"    foreach (var kvp in value)");
                    builder.AppendLine($"    {{");
                    builder.AppendLine($"        var bridgedValue = kvp.Value as global::{valueBridgeInfo.BridgeFullName};");
                    builder.AppendLine($"        result[kvp.Key] = bridgedValue?._instance;");
                    builder.AppendLine($"    }}");
                    builder.AppendLine($"    {instanceAssignment} = result;");
                    
                    builder.AppendLine("}");
                }
                // Check if property type is a collection with elements that need unwrapping
                else if (IsCollection(property.Type, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    builder.AppendLine("if (value == null)");
                    builder.AppendLine("{");
                    builder.AppendLine($"    {instanceAssignment} = null;");
                    builder.AppendLine("}");
                    builder.AppendLine("else");
                    builder.AppendLine("{");
                    
                    // Convert bridge collection back to original type
                    builder.AppendLine($"    var __convertFunc = new global::System.Func<dynamic, dynamic>(item => item?._instance);");
                    builder.AppendLine($"    var enumerable = (global::System.Collections.IEnumerable)value;");
                    
                    if (property.Type is IArrayTypeSymbol)
                    {
                        builder.AppendLine($"    {instanceAssignment} = enumerable.Cast<dynamic>().Select(__convertFunc).ToArray();");
                    }
                    else if (IsListType(property.Type))
                    {
                        builder.AppendLine($"    {instanceAssignment} = enumerable.Cast<dynamic>().Select(__convertFunc).ToList();");
                    }
                    else
                    {
                        builder.AppendLine($"    {instanceAssignment} = enumerable.Cast<dynamic>().Select(__convertFunc);");
                    }
                    
                    builder.AppendLine("}");
                }
                else if (_typeResolver.NeedsWrapping(property.Type))
                {
                    // For auto-generated bridges, we need to check if it's a bridge type and unwrap properly
                    var bridgeInfo = GetBridgeInfo(property.Type);
                    if (bridgeInfo.IsExplicitlyMarked)
                    {
                        // User-defined bridge - access _instance directly
                        builder.AppendLine($"{instanceAssignment} = value?._instance;");
                    }
                    else
                    {
                        // Auto-generated bridge - use GetUnwrapped method or cast and access
                        builder.AppendLine($"if (value == null)");
                        builder.AppendLine($"{{");
                        builder.AppendLine($"    {instanceAssignment} = null;");
                        builder.AppendLine($"}}");
                        builder.AppendLine($"else");
                        builder.AppendLine($"{{");
                        builder.AppendLine($"    var bridgedValue = value as global::{bridgeInfo.BridgeFullName};");
                        builder.AppendLine($"    {instanceAssignment} = bridgedValue?._instance;");
                        builder.AppendLine($"}}");
                    }
                }
                else
                {
                    builder.AppendLine($"{instanceAssignment} = value;");
                }
                
                builder.CloseBlock();
            }
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateMethod(CodeBuilder builder, MethodModel method)
        {
            // Validate method for AppDomain compatibility
            if (_context.HasValue)
            {
                var diagnostics = _methodValidator.ValidateMethod(method, method.Symbol, method.Symbol.Locations.FirstOrDefault() ?? Location.None);
                foreach (var diagnostic in diagnostics)
                {
                    _context.Value.ReportDiagnostic(diagnostic);
                }
            }
            
            // Check if this is an explicit interface implementation
            if (method.IsInterfaceMember && method.DeclaringInterface != null)
            {
                // Generate explicit interface implementation
                GenerateExplicitInterfaceMethod(builder, method);
            }
            else
            {
                // Check if method is async (returns Task or Task<T>)
                var isAsync = IsTaskType(method.ReturnType, out var taskResultType);
                
                if (isAsync)
                {
                    // Generate async wrapper method that handles the async call directly
                    GenerateAsyncBridgeMethod(builder, method, taskResultType);
                }
                else
                {
                    // Generate normal synchronous method
                    GenerateNormalMethod(builder, method);
                }
            }
        }
        
        private void GenerateAsyncBridgeMethod(CodeBuilder builder, MethodModel method, ITypeSymbol? taskResultType)
        {
            var returnType = _typeResolver.ResolveType(method.ReturnType);
            var parameters = GenerateParameterList(method.Parameters);
            
            builder.OpenBlock($"public async {returnType} {method.Name}({parameters})");
            builder.AppendLine("CheckDisposed();");
            
            // Wrap in try-catch for exception handling
            builder.OpenBlock("try");
            
            // Generate direct async call
            var args = GenerateArgumentList(method.Parameters);
            var methodCall = $"_instance.{method.Name}({args})";
            
            // Handle ValueTask conversion to Task if needed
            var isValueTask = method.ReturnType is INamedTypeSymbol namedType && 
                             (namedType.Name == "ValueTask" || 
                              (namedType.IsGenericType && namedType.ConstructedFrom?.Name == "ValueTask"));
            
            if (isValueTask)
            {
                methodCall = $"{methodCall}.AsTask()";
            }
            
            if (taskResultType == null)
            {
                // Task (non-generic) - just await
                builder.AppendLine($"await {methodCall};");
            }
            else if (_typeResolver.NeedsWrapping(taskResultType))
            {
                // Task<T> where T needs wrapping
                builder.AppendLine($"var result = await {methodCall};");
                
                // Handle collections specially
                if (IsCollection(taskResultType, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    GenerateCollectionReturn(builder, taskResultType, elementType, "result");
                }
                else
                {
                    // Single object wrapping
                    var bridgeInfo = GetBridgeInfo(taskResultType);
                    if (bridgeInfo.IsExplicitlyMarked)
                    {
                        // User-defined bridge - use Create with factory
                        builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.Create(() => result) : null!;");
                    }
                    else
                    {
                        // Auto-generated bridge - use GetOrCreate
                        builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
                    }
                }
            }
            else
            {
                // Task<T> where T doesn't need wrapping
                builder.AppendLine($"return await {methodCall};");
            }
            
            builder.CloseBlock(); // try
            
            // Add catch block for non-serializable exceptions
            builder.OpenBlock("catch (global::System.Exception ex) when (!IsSerializableException(ex))");
            builder.AppendLine("// Wrap non-serializable exceptions in a serializable wrapper");
            builder.AppendLine("throw new global::System.InvalidOperationException(");
            builder.AppendLine($"    $\"Exception in method {method.Name}: {{ex.GetType().Name}}: {{ex.Message}}\",");
            builder.AppendLine("    ex.InnerException);");
            builder.CloseBlock(); // catch
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        
        private void GenerateNormalMethod(CodeBuilder builder, MethodModel method)
        {
            var returnType = _typeResolver.ResolveType(method.ReturnType);
            var parameters = GenerateParameterList(method.Parameters);
            
            builder.OpenBlock($"public {returnType} {method.Name}({parameters})");
            builder.AppendLine("CheckDisposed();");
            
            // Generate method call with exception wrapping
            var args = GenerateArgumentList(method.Parameters);
            var methodCall = $"_instance.{method.Name}({args})";
            
            // Wrap in try-catch for exception handling
            builder.OpenBlock("try");
            
            if (method.ReturnType.SpecialType == SpecialType.System_Void)
            {
                builder.AppendLine($"{methodCall};");
            }
            else
            {
                GenerateReturnStatement(builder, method.ReturnType, methodCall);
            }
            
            builder.CloseBlock(); // try
            
            // Add catch block for non-serializable exceptions
            builder.OpenBlock("catch (global::System.Exception ex) when (!IsSerializableException(ex))");
            builder.AppendLine("// Wrap non-serializable exceptions in a serializable wrapper");
            builder.AppendLine("throw new global::System.InvalidOperationException(");
            builder.AppendLine($"    $\"Exception in method {method.Name}: {{ex.GetType().Name}}: {{ex.Message}}\",");
            builder.AppendLine("    ex.InnerException);");
            builder.CloseBlock(); // catch
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateExplicitInterfaceMethod(CodeBuilder builder, MethodModel method)
        {
            var interfaceType = _typeResolver.ResolveType(method.DeclaringInterface!);
            var returnType = _typeResolver.ResolveType(method.ReturnType);
            var parameters = GenerateParameterList(method.Parameters);
            
            // Generate explicit interface implementation
            builder.OpenBlock($"{returnType} {interfaceType}.{method.Name}({parameters})");
            builder.AppendLine("CheckDisposed();");
            
            // Generate method call with exception wrapping
            var args = GenerateArgumentList(method.Parameters);
            var methodCall = $"(({interfaceType})_instance).{method.Name}({args})";
            
            // Wrap in try-catch for exception handling
            builder.OpenBlock("try");
            
            if (method.ReturnType.SpecialType == SpecialType.System_Void)
            {
                builder.AppendLine($"{methodCall};");
            }
            else
            {
                GenerateReturnStatement(builder, method.ReturnType, methodCall);
            }
            
            builder.CloseBlock(); // try
            
            // Add catch block for non-serializable exceptions
            builder.OpenBlock("catch (global::System.Exception ex) when (!IsSerializableException(ex))");
            builder.AppendLine("// Wrap non-serializable exceptions in a serializable wrapper");
            builder.AppendLine("throw new global::System.InvalidOperationException(");
            builder.AppendLine($"    $\"Exception in method {interfaceType}.{method.Name}: {{ex.GetType().Name}}: {{ex.Message}}\",");
            builder.AppendLine("    ex.InnerException);");
            builder.CloseBlock(); // catch
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateReturnStatement(CodeBuilder builder, ITypeSymbol returnType, string methodCall)
        {
            // Check if return type is a dictionary that might need wrapping
            if (IsDictionary(returnType, out var keyType, out var valueType))
            {
                if (_typeResolver.NeedsWrapping(valueType))
                {
                    // Dictionary with values that need wrapping
                    GenerateDictionaryReturn(builder, returnType, keyType, valueType, methodCall);
                }
                else
                {
                    // Dictionary with values that don't need wrapping
                    builder.AppendLine($"return {methodCall};");
                }
            }
            // Check if return type is a collection that might need wrapping
            else if (IsCollection(returnType, out var elementType))
            {
                if (_typeResolver.NeedsWrapping(elementType))
                {
                    // Collection with elements that need wrapping
                    GenerateCollectionReturn(builder, returnType, elementType, methodCall);
                }
                else
                {
                    // Collection with elements that don't need wrapping
                    builder.AppendLine($"return {methodCall};");
                }
            }
            else if (_typeResolver.NeedsWrapping(returnType))
            {
                // Single object wrapping
                var bridgeInfo = GetBridgeInfo(returnType);
                builder.AppendLine($"var result = {methodCall};");
                if (bridgeInfo.IsExplicitlyMarked)
                {
                    // User-defined bridge - use Create with factory
                    builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.Create(() => result) : null!;");
                }
                else
                {
                    // Auto-generated bridge - use GetOrCreate
                    builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
                }
            }
            else
            {
                builder.AppendLine($"return {methodCall};");
            }
        }
        
        private void GenerateCollectionReturn(
            CodeBuilder builder, 
            ITypeSymbol collectionType, 
            ITypeSymbol elementType,
            string methodCall)
        {
            var bridgeInfo = GetBridgeInfo(elementType);
            
            // Check if we already have the result variable
            if (!methodCall.Equals("result", StringComparison.Ordinal) && !methodCall.Equals("value", StringComparison.Ordinal))
            {
                builder.AppendLine($"var result = {methodCall};");
                methodCall = "result";
            }
            
            builder.AppendLine($"if ({methodCall} == null) return null!;");
            
            // Create a function variable to avoid lambda with dynamic
            var funcName = $"__bridgeFunc_{elementType.Name}";
            builder.AppendLine($"var {funcName} = new global::System.Func<dynamic, global::{bridgeInfo.BridgeFullName}>(item => ");
            if (bridgeInfo.IsExplicitlyMarked)
            {
                // User-defined bridge - use Create with factory
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.Create(() => item) : null!);");
            }
            else
            {
                // Auto-generated bridge - use GetOrCreate
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null!);");
            }
            
            // Cast to IEnumerable first to ensure Cast method is available
            builder.AppendLine($"var enumerable = (global::System.Collections.IEnumerable){methodCall};");
            
            // Determine the collection type and generate appropriate wrapping
            if (collectionType is IArrayTypeSymbol)
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToArray();");
            }
            else if (IsListType(collectionType))
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToList();");
            }
            else
            {
                // Default to IEnumerable
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName});");
            }
        }
        
        private void GenerateDictionaryReturn(
            CodeBuilder builder,
            ITypeSymbol dictionaryType,
            ITypeSymbol keyType,
            ITypeSymbol valueType,
            string methodCall)
        {
            var valueBridgeInfo = GetBridgeInfo(valueType);
            
            // Check if we already have the result variable
            if (!methodCall.Equals("result", StringComparison.Ordinal) && !methodCall.Equals("value", StringComparison.Ordinal))
            {
                builder.AppendLine($"var dict = {methodCall};");
                methodCall = "dict";
            }
            
            builder.AppendLine($"if ({methodCall} == null) return null!;");
            
            // Create the wrapped dictionary
            var keyTypeName = _typeResolver.ResolveType(keyType);
            var valueTypeName = _typeResolver.ResolveType(valueType);
            
            builder.AppendLine($"var result = new global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>();");
            builder.AppendLine($"foreach (var kvp in {methodCall})");
            builder.AppendLine("{");
            if (valueBridgeInfo.IsExplicitlyMarked)
            {
                // User-defined bridge - use Create with factory
                builder.AppendLine($"    var wrappedValue = kvp.Value != null ? global::{valueBridgeInfo.BridgeFullName}.Create(() => kvp.Value) : null!;");
            }
            else
            {
                // Auto-generated bridge - use GetOrCreate
                builder.AppendLine($"    var wrappedValue = kvp.Value != null ? global::{valueBridgeInfo.BridgeFullName}.GetOrCreate(kvp.Value) : null!;");
            }
            builder.AppendLine($"    result[kvp.Key] = wrappedValue;");
            builder.AppendLine("}");
            builder.AppendLine("return result;");
        }
        
        private string GenerateParameterList(IList<ParameterModel> parameters)
        {
            return string.Join(", ", parameters.Select(p =>
            {
                var paramType = _typeResolver.ResolveType(p.Type);
                var defaultValue = p.HasDefaultValue ? $" = {FormatDefaultValue(p.DefaultValue)}" : "";
                return $"{paramType} {EscapeIdentifier(p.Name)}{defaultValue}";
            }));
        }
        
        private string GenerateArgumentList(IList<ParameterModel> parameters)
        {
            return string.Join(", ", parameters.Select(p =>
            {
                if (_typeResolver.NeedsWrapping(p.Type))
                {
                    // For parameters that need wrapping, we need to unwrap them properly
                    var bridgeInfo = GetBridgeInfo(p.Type);
                    if (bridgeInfo.IsExplicitlyMarked)
                    {
                        // User-defined bridge - access _instance directly
                        return $"{EscapeIdentifier(p.Name)}?._instance";
                    }
                    else
                    {
                        // Auto-generated bridge - need to cast and access
                        return $"(({EscapeIdentifier(p.Name)} as global::{bridgeInfo.BridgeFullName})?._instance ?? {EscapeIdentifier(p.Name)})";
                    }
                }
                return EscapeIdentifier(p.Name);
            }));
        }
        
        private string ResolveEventType(ITypeSymbol eventType)
        {
            // For delegate types, we want to preserve the delegate but resolve any generic type arguments
            if (eventType is INamedTypeSymbol namedType && namedType.IsGenericType && namedType.TypeArguments.Length > 0)
            {
                // Get the base delegate type without generic arguments
                var baseTypeName = namedType.ConstructedFrom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                // Resolve each type argument through the type resolver
                var resolvedArgs = namedType.TypeArguments
                    .Select(arg => _typeResolver.ResolveType(arg))
                    .ToList();
                
                // Reconstruct the generic type with resolved arguments
                return $"{baseTypeName.Substring(0, baseTypeName.IndexOf('<'))}<{string.Join(", ", resolvedArgs)}>";
            }
            
            // For non-generic delegate types, use as-is
            return eventType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        private void GenerateEvent(CodeBuilder builder, EventModel evt)
        {
            // For events, we need to preserve the delegate type but resolve any generic type arguments
            // that may need bridging (e.g., EventHandler<CustomEventArgs> -> EventHandler<CustomEventArgsBridge>)
            var eventType = ResolveEventType(evt.Type);
            
            // Check if this is an explicit interface implementation
            if (evt.IsInterfaceMember && evt.DeclaringInterface != null)
            {
                var interfaceType = _typeResolver.ResolveType(evt.DeclaringInterface);
                builder.OpenBlock($"event {eventType} {interfaceType}.{evt.Name}");
                builder.AppendLine($"add {{ CheckDisposed(); (({interfaceType})_instance).{evt.Name} += value; }}");
                builder.AppendLine($"remove {{ CheckDisposed(); (({interfaceType})_instance).{evt.Name} -= value; }}");
            }
            else
            {
                builder.OpenBlock($"public event {eventType} {evt.Name}");
                builder.AppendLine($"add {{ CheckDisposed(); _instance.{evt.Name} += value; }}");
                builder.AppendLine($"remove {{ CheckDisposed(); _instance.{evt.Name} -= value; }}");
            }
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        
        
        private void GenerateStaticInstanceProperty(CodeBuilder builder, BridgeTypeInfo bridgeInfo, TypeModel typeModel)
        {
            // Only generate for explicitly marked types that might have static Instance properties
            if (!bridgeInfo.IsExplicitlyMarked)
            {
                return;
            }

            // Check if the target type has a static Instance property
            var targetType = typeModel.Symbol;
            var staticInstanceProperty = targetType.GetMembers("Instance")
                .OfType<IPropertySymbol>()
                .FirstOrDefault(p => p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null);
                
            if (staticInstanceProperty != null)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Gets a bridge around the static Instance property of {targetType.Name}");
                builder.AppendLine("/// </summary>");
                builder.OpenBlock($"public static {bridgeInfo.BridgeClassName} Instance");
                builder.OpenBlock("get");
                builder.AppendLine($"var targetInstance = global::{targetType.ToDisplayString()}.Instance;");
                builder.AppendLine($"// Note: This creates a bridge in the current AppDomain, not an isolated one");
                // Extract just the class name without generic parameters for the constructor
                var ctorName = bridgeInfo.BridgeClassName;
                var bracketIdx = ctorName.IndexOf('<');
                if (bracketIdx > 0)
                {
                    ctorName = ctorName.Substring(0, bracketIdx);
                }
                builder.AppendLine($"return new {ctorName}(targetInstance, global::System.AppDomain.CurrentDomain);");
                builder.CloseBlock();
                builder.CloseBlock();
                builder.AppendLine();
            }
        }
        
        private void GenerateWrappedInstanceAccessor(CodeBuilder builder, TypeModel typeModel)
        {
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Gets the wrapped instance of {typeModel.FullName}.");
            builder.AppendLine("/// This is an advanced feature - use with caution as it bypasses the bridge's safety mechanisms.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("/// <returns>The wrapped instance as an object</returns>");
            builder.OpenBlock("public object GetWrappedInstance()");
            builder.AppendLine("CheckDisposed();");
            builder.AppendLine("return _instance;");
            builder.CloseBlock();
            builder.AppendLine();
            
            // Also generate a typed version for convenience
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Gets the wrapped instance of {typeModel.FullName} with type casting.");
            builder.AppendLine("/// This is an advanced feature - use with caution as it bypasses the bridge's safety mechanisms.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("/// <typeparam name=\"TResult\">The type to cast the wrapped instance to</typeparam>");
            builder.AppendLine("/// <returns>The wrapped instance cast to type TResult</returns>");
            builder.OpenBlock("public TResult GetWrappedInstance<TResult>()");
            builder.AppendLine("CheckDisposed();");
            builder.AppendLine("return (TResult)(object)_instance;");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateHelperMethods(CodeBuilder builder)
        {
            // Generate IsSerializableException helper method
            builder.AppendLine("/// <summary>");
            builder.AppendLine("/// Checks if an exception can be properly serialized across AppDomain boundaries");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock("private static bool IsSerializableException(global::System.Exception ex)");
            builder.AppendLine("if (ex == null) return true;");
            builder.AppendLine();
            builder.AppendLine("// Check if the exception type has the [Serializable] attribute");
            builder.AppendLine("var exceptionType = ex.GetType();");
            builder.AppendLine("if (!exceptionType.IsSerializable) return false;");
            builder.AppendLine();
            builder.AppendLine("// Check common serializable exception types");
            builder.AppendLine("if (ex is global::System.ArgumentException ||");
            builder.AppendLine("    ex is global::System.InvalidOperationException ||");
            builder.AppendLine("    ex is global::System.NotSupportedException ||");
            builder.AppendLine("    ex is global::System.NotImplementedException ||");
            builder.AppendLine("    ex is global::System.UnauthorizedAccessException ||");
            builder.AppendLine("    ex is global::System.TimeoutException ||");
            builder.AppendLine("    ex is global::System.ApplicationException ||");
            builder.AppendLine("    ex is global::System.SystemException)");
            builder.AppendLine("    return true;");
            builder.AppendLine();
            builder.AppendLine("// For other exception types, try to determine if they're serializable");
            builder.AppendLine("// by checking if they have a serialization constructor");
            builder.AppendLine("try");
            builder.AppendLine("{");
            builder.AppendLine("    var constructor = exceptionType.GetConstructor(");
            builder.AppendLine("        global::System.Reflection.BindingFlags.NonPublic | global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance,");
            builder.AppendLine("        null,");
            builder.AppendLine("        new[] { typeof(global::System.Runtime.Serialization.SerializationInfo), typeof(global::System.Runtime.Serialization.StreamingContext) },");
            builder.AppendLine("        null);");
            builder.AppendLine("    return constructor != null;");
            builder.AppendLine("}");
            builder.AppendLine("catch");
            builder.AppendLine("{");
            builder.AppendLine("    return false;");
            builder.AppendLine("}");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateDisposalImplementation(CodeBuilder builder, BridgeTypeInfo bridgeInfo, TypeModel typeModel)
        {
            // Check if the target type implements IDisposable
            var targetImplementsIDisposable = typeModel.Interfaces.Any(i => 
                i.Name == "IDisposable" && 
                i.ContainingNamespace?.ToDisplayString() == "System");
                
            // Check if the target type already has a Dispose() method
            var hasDisposeMethod = typeModel.Methods.Any(m => 
                m.Name == "Dispose" && 
                m.Parameters.Count == 0 && 
                !m.IsIgnored);
                
            if (!hasDisposeMethod)
            {
                // Generate Dispose method only if target doesn't have one
                builder.AppendLine("/// <summary>");
                builder.AppendLine("/// Disposes the bridge and unloads the associated AppDomain");
                builder.AppendLine("/// </summary>");
                builder.OpenBlock("public void Dispose()");
                builder.AppendLine("Dispose(true);");
                builder.AppendLine("GC.SuppressFinalize(this);");
                builder.CloseBlock();
                builder.AppendLine();
            }
            
            // Generate protected Dispose method
            var disposeModifier = bridgeInfo.IsExplicitlyMarked ? "protected virtual" : "protected";
            builder.OpenBlock($"{disposeModifier} void Dispose(bool disposing)");
            builder.OpenBlock("if (!_disposed)");
            builder.OpenBlock("if (disposing)");
            builder.AppendLine("// Dispose managed resources");
            
            // Forward disposal to wrapped instance if it implements IDisposable
            if (targetImplementsIDisposable)
            {
                builder.AppendLine("// Forward Dispose to wrapped instance");
                builder.OpenBlock("try");
                builder.AppendLine("(_instance as global::System.IDisposable)?.Dispose();");
                builder.CloseBlock();
                builder.OpenBlock("catch (global::System.Exception ex)");
                builder.AppendLine("// Log but don't throw from Dispose");
                builder.AppendLine("global::System.Diagnostics.Debug.WriteLine($\"Failed to dispose wrapped instance: {ex.Message}\");");
                builder.CloseBlock();
                builder.AppendLine();
            }
            
            builder.OpenBlock("if (_appDomain != null && _appDomain != global::System.AppDomain.CurrentDomain)");
            builder.OpenBlock("try");
            builder.AppendLine("global::System.AppDomain.Unload(_appDomain);");
            builder.CloseBlock();
            builder.OpenBlock("catch (global::System.Exception ex)");
            builder.AppendLine("// Log but don't throw from Dispose");
            builder.AppendLine("global::System.Diagnostics.Debug.WriteLine($\"Failed to unload AppDomain: {ex.Message}\");");
            builder.CloseBlock();
            builder.CloseBlock();
            builder.CloseBlock();
            builder.AppendLine("_disposed = true;");
            builder.CloseBlock();
            builder.CloseBlock();
            builder.AppendLine();
            
            // Generate CheckDisposed method
            builder.OpenBlock("private void CheckDisposed()");
            builder.OpenBlock("if (_disposed)");
            builder.AppendLine("throw new global::System.ObjectDisposedException(GetType().FullName);");
            builder.CloseBlock();
            builder.CloseBlock();
        }
        
        private BridgeTypeInfo GetBridgeInfo(ITypeSymbol type)
        {
            if (_typeResolver.TryGetBridgeInfo(type, out var info) && info != null)
            {
                return info;
            }

            throw new InvalidOperationException($"No bridge info found for type {type}");
        }
        
        private bool IsCollection(ITypeSymbol type, out ITypeSymbol elementType)
        {
            elementType = null!;
            
            if (type is IArrayTypeSymbol arrayType)
            {
                elementType = arrayType.ElementType;
                return true;
            }
            
            if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                if (name == "List" || name == "IList" || name == "IEnumerable" || name == "ICollection")
                {
                    elementType = namedType.TypeArguments.FirstOrDefault() ?? throw new InvalidOperationException();
                    return true;
                }
            }
            
            return false;
        }
        
        private bool IsDictionary(ITypeSymbol type, out ITypeSymbol keyType, out ITypeSymbol valueType)
        {
            keyType = null!;
            valueType = null!;
            
            if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                if (name == "Dictionary" || name == "IDictionary")
                {
                    if (namedType.TypeArguments.Length == 2)
                    {
                        keyType = namedType.TypeArguments[0];
                        valueType = namedType.TypeArguments[1];
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        private bool IsListType(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                return name == "List" || name == "IList";
            }
            return false;
        }
        
        private bool IsTaskType(ITypeSymbol type, out ITypeSymbol? taskResultType)
        {
            taskResultType = null;
            
            if (type is INamedTypeSymbol namedType)
            {
                var fullName = namedType.ToDisplayString();
                
                // Check for Task (non-generic)
                if (fullName == "System.Threading.Tasks.Task")
                {
                    return true;
                }
                
                // Check for Task<T>
                if (namedType.IsGenericType && namedType.ConstructedFrom?.Name == "Task")
                {
                    taskResultType = namedType.TypeArguments.FirstOrDefault();
                    return true;
                }
                
                // Check for ValueTask (non-generic)
                if (fullName == "System.Threading.Tasks.ValueTask")
                {
                    return true;
                }
                
                // Check for ValueTask<T>
                if (namedType.IsGenericType && namedType.ConstructedFrom?.Name == "ValueTask")
                {
                    taskResultType = namedType.TypeArguments.FirstOrDefault();
                    return true;
                }
            }
            
            return false;
        }
        
        private void GenerateAsyncReturnStatement(
            CodeBuilder builder, 
            ITypeSymbol returnType, 
            ITypeSymbol? taskResultType, 
            string methodCall)
        {
            // For Task (non-generic), just await the call
            if (taskResultType == null)
            {
                builder.AppendLine($"await {methodCall};");
                return;
            }
            
            // For Task<T>, we need to await and potentially wrap the result
            if (_typeResolver.NeedsWrapping(taskResultType))
            {
                // Handle collections specially
                if (IsCollection(taskResultType, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    builder.AppendLine($"var result = await {methodCall};");
                    GenerateCollectionReturnForAsync(builder, taskResultType, elementType);
                }
                else
                {
                    // Single object wrapping
                    var bridgeInfo = GetBridgeInfo(taskResultType);
                    builder.AppendLine($"var result = await {methodCall};");
                    if (bridgeInfo.IsExplicitlyMarked)
                    {
                        // User-defined bridge - use Create with factory
                        builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.Create(() => result) : null!;");
                    }
                    else
                    {
                        // Auto-generated bridge - use GetOrCreate
                        builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
                    }
                }
            }
            else
            {
                builder.AppendLine($"return await {methodCall};");
            }
        }
        
        private void GenerateCollectionReturnForAsync(
            CodeBuilder builder, 
            ITypeSymbol collectionType, 
            ITypeSymbol elementType)
        {
            var bridgeInfo = GetBridgeInfo(elementType);
            builder.AppendLine("if (result == null) return null!;");
            
            // Create a function variable to avoid lambda with dynamic
            var funcName = $"__bridgeFunc_{elementType.Name}";
            builder.AppendLine($"var {funcName} = new global::System.Func<dynamic, global::{bridgeInfo.BridgeFullName}>(item => ");
            if (bridgeInfo.IsExplicitlyMarked)
            {
                // User-defined bridge - use Create with factory
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.Create(() => item) : null!);");
            }
            else
            {
                // Auto-generated bridge - use GetOrCreate
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null!);");
            }
            
            // Cast to IEnumerable first to ensure Cast method is available
            builder.AppendLine($"var enumerable = (global::System.Collections.IEnumerable)result;");
            
            // Determine the collection type and generate appropriate wrapping
            if (collectionType is IArrayTypeSymbol)
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToArray();");
            }
            else if (IsListType(collectionType))
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToList();");
            }
            else
            {
                // Default to IEnumerable
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName});");
            }
        }
        
        private string FormatDefaultValue(object? value)
        {
            if (value == null)
            {
                return "null";
            }
            if (value is string str)
            {
                return $"@\"{str.Replace("\"", "\"\"")}\"";
            }
            if (value is bool b)
            {
                return b ? "true" : "false";
            }
            return value.ToString() ?? "null";
        }
        
        private bool IsBuiltInType(string typeName)
        {
            // Check for common built-in types that don't need global:: prefix
            return typeName == "string" || 
                   typeName == "int" || 
                   typeName == "long" || 
                   typeName == "double" || 
                   typeName == "float" || 
                   typeName == "bool" || 
                   typeName == "byte" || 
                   typeName == "short" || 
                   typeName == "decimal" || 
                   typeName == "char" ||
                   typeName == "object" ||
                   typeName == "dynamic";
        }
        
        private string EscapeIdentifier(string identifier)
        {
            var keywords = new HashSet<string>
            {
                "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
                "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum",
                "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto",
                "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace",
                "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
                "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
                "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked",
                "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
            };
            
            return keywords.Contains(identifier) ? $"@{identifier}" : identifier;
        }
        
        private bool InheritsFromMarshalByRefObject(INamedTypeSymbol type)
        {
            var currentType = type.BaseType;
            while (currentType != null)
            {
                if (currentType.Name == "MarshalByRefObject" && 
                    currentType.ContainingNamespace?.ToDisplayString() == "System")
                {
                    return true;
                }
                currentType = currentType.BaseType;
            }
            return false;
        }
    }
}