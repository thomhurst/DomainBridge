using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using DomainBridge.SourceGenerators.Models;

namespace DomainBridge.SourceGenerators.Services
{
    /// <summary>
    /// Enhanced bridge class generator that handles automatic type resolution and wrapping
    /// </summary>
    internal sealed class EnhancedBridgeClassGenerator
    {
        private readonly BridgeTypeResolver _typeResolver;
        private readonly TypeAnalyzer _typeAnalyzer;
        private readonly MethodValidator _methodValidator;
        private GeneratorExecutionContext? _context;
        
        public EnhancedBridgeClassGenerator(BridgeTypeResolver typeResolver, TypeAnalyzer typeAnalyzer)
        {
            _typeResolver = typeResolver ?? throw new ArgumentNullException(nameof(typeResolver));
            _typeAnalyzer = typeAnalyzer ?? throw new ArgumentNullException(nameof(typeAnalyzer));
            _methodValidator = new MethodValidator();
        }
        
        public string GenerateBridgeClass(
            BridgeTypeInfo bridgeInfo,
            INamedTypeSymbol targetType,
            AttributeConfiguration? config = null,
            GeneratorExecutionContext? context = null)
        {
            _context = context;
            var typeModel = _typeAnalyzer.AnalyzeType(targetType);
            var builder = new CodeBuilder();
            
            GenerateFileHeader(builder);
            
            // For explicitly marked partial bridges, use the original namespace
            var namespaceToUse = bridgeInfo.IsExplicitlyMarked 
                ? targetType.ContainingNamespace.ToDisplayString()
                : bridgeInfo.BridgeNamespace;
            
            builder.AppendLine($"namespace {namespaceToUse}");
            builder.OpenBlock("");
            
            GenerateBridgeClass(builder, bridgeInfo, typeModel, config);
            
            builder.CloseBlock();
            
            return builder.ToString();
        }
        
        private void GenerateFileHeader(CodeBuilder builder)
        {
            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using System.Linq;");
            builder.AppendLine("using System.Collections.Concurrent;");
            builder.AppendLine("using DomainBridge;");
            builder.AppendLine("using DomainBridge.Runtime;");
            builder.AppendLine();
        }
        
        private void GenerateBridgeClass(
            CodeBuilder builder, 
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel, 
            AttributeConfiguration? config)
        {
            // Generate class declaration
            var classDeclaration = bridgeInfo.IsExplicitlyMarked
                ? $"public partial class {bridgeInfo.BridgeClassName} : global::System.MarshalByRefObject"
                : $"public sealed class {bridgeInfo.BridgeClassName} : global::System.MarshalByRefObject";
                
            // Add interfaces
            if (typeModel.Interfaces.Any())
            {
                var interfaceList = string.Join(", ", typeModel.Interfaces.Select(i => 
                    _typeResolver.ResolveType(i)));
                classDeclaration += $", {interfaceList}";
            }
            
            builder.OpenBlock(classDeclaration);
            
            GenerateFields(builder);
            GenerateConstructors(builder, bridgeInfo, typeModel, config);
            GenerateFactoryMethods(builder, bridgeInfo, typeModel, config);
            GenerateStaticInstanceProperty(builder, bridgeInfo, typeModel);
            GenerateMembers(builder, typeModel);
            GenerateHelperMethods(builder);
            GenerateDisposalMethod(builder, bridgeInfo, typeModel);
            
            builder.CloseBlock();
        }
        
        private void GenerateFields(CodeBuilder builder)
        {
            builder.AppendLine("private static readonly object _lock = new object();");
            builder.AppendLine("private static global::System.AppDomain? _isolatedDomain;");
            builder.AppendLine("private static dynamic? _remoteProxy;");
            builder.AppendLine("internal readonly dynamic _instance;");
            builder.AppendLine();
        }
        
        private void GenerateConstructors(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel,
            AttributeConfiguration? config = null)
        {
            // Constructor that takes the wrapped instance
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Wraps an existing instance of {typeModel.FullName}");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock($"public {bridgeInfo.BridgeClassName}(dynamic instance)");
            builder.AppendLine("_instance = instance ?? throw new global::System.ArgumentNullException(nameof(instance));");
            builder.CloseBlock();
            builder.AppendLine();
            
            // Default constructor for explicitly marked types (needed when created in isolated domain)
            if (bridgeInfo.IsExplicitlyMarked)
            {
                builder.OpenBlock($"public {bridgeInfo.BridgeClassName}()");
                builder.AppendLine("// When created in isolated domain, create the target instance directly");
                
                // Check if a factory method is configured
                if (!string.IsNullOrEmpty(config?.FactoryMethod))
                {
                    builder.AppendLine($"// Using factory method: {config.FactoryMethod}");
                    builder.AppendLine($"var bridgeType = typeof({bridgeInfo.BridgeClassName});");
                    builder.AppendLine($"var factoryMethod = bridgeType.GetMethod(\"{config.FactoryMethod}\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);");
                    builder.OpenBlock("if (factoryMethod != null)");
                    builder.AppendLine("_instance = factoryMethod.Invoke(null, null);");
                    builder.CloseBlock();
                    builder.OpenBlock("else");
                    builder.AppendLine($"throw new global::System.InvalidOperationException(\"Factory method '{config.FactoryMethod}' not found on type {bridgeInfo.BridgeClassName}\");");
                    builder.CloseBlock();
                }
                else
                {
                    builder.AppendLine($"var targetType = typeof({typeModel.FullName});");
                    builder.AppendLine("var instanceProperty = targetType.GetProperty(\"Instance\", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);");
                    builder.OpenBlock("if (instanceProperty != null && instanceProperty.CanRead)");
                    builder.AppendLine("_instance = instanceProperty.GetValue(null);");
                    builder.CloseBlock();
                    builder.OpenBlock("else");
                    builder.AppendLine("_instance = Activator.CreateInstance(targetType);");
                    builder.CloseBlock();
                }
                
                builder.CloseBlock();
                builder.AppendLine();
            }
            
            // Static factory method for cached instance creation
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Gets or creates a cached bridge for the given instance");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock($"internal static {bridgeInfo.BridgeClassName} GetOrCreate(dynamic instance)");
            builder.AppendLine("if (instance == null) return null!;");
            builder.AppendLine($"var factory = new global::System.Func<dynamic, {bridgeInfo.BridgeClassName}>(i => new {bridgeInfo.BridgeClassName}(i));");
            builder.AppendLine($"return global::DomainBridge.Runtime.BridgeInstanceCache.GetOrCreate<{bridgeInfo.BridgeClassName}, dynamic>(");
            builder.AppendLine($"    (dynamic)instance, factory);");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateFactoryMethods(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel,
            AttributeConfiguration? config)
        {
            // Generate CreateIsolated method only for explicitly marked types
            if (bridgeInfo.IsExplicitlyMarked)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine("/// Creates an isolated instance in a separate AppDomain");
                builder.AppendLine("/// </summary>");
                builder.OpenBlock($"public static {bridgeInfo.BridgeClassName} CreateIsolated(global::DomainBridge.DomainConfiguration? config = null)");
                builder.AppendLine("EnsureIsolatedDomain(config);");
                builder.AppendLine("return GetOrCreateRemoteBridge();");
                builder.CloseBlock();
                builder.AppendLine();
                
                GenerateEnsureIsolatedDomainMethod(builder, bridgeInfo, typeModel, config);
                GenerateGetOrCreateRemoteBridgeMethod(builder, bridgeInfo);
            }
        }
        
        private void GenerateMembers(CodeBuilder builder, TypeModel typeModel)
        {
            // Generate properties
            foreach (var property in typeModel.Properties.Where(p => !p.IsIgnored))
            {
                GenerateProperty(builder, property);
            }
            
            // Generate methods
            foreach (var method in typeModel.Methods.Where(m => !m.IsIgnored))
            {
                GenerateMethod(builder, method);
            }
            
            // Generate events
            foreach (var evt in typeModel.Events.Where(e => !e.IsIgnored))
            {
                GenerateEvent(builder, evt);
            }
        }
        
        private void GenerateProperty(CodeBuilder builder, PropertyModel property)
        {
            var propertyType = _typeResolver.ResolveType(property.Type);
            
            builder.OpenBlock($"public {propertyType} {property.Name}");
            
            if (property.HasGetter)
            {
                builder.OpenBlock("get");
                
                // Check if property type is a dictionary with values that need wrapping
                if (IsDictionary(property.Type, out var keyType, out var valueType) && _typeResolver.NeedsWrapping(valueType))
                {
                    builder.AppendLine($"var value = _instance.{property.Name};");
                    builder.AppendLine("if (value == null) return null!;");
                    GenerateDictionaryReturn(builder, property.Type, keyType, valueType, "value");
                }
                // Check if property type is a collection with elements that need wrapping
                else if (IsCollection(property.Type, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    builder.AppendLine($"var value = _instance.{property.Name};");
                    builder.AppendLine("if (value == null) return null!;");
                    GenerateCollectionReturn(builder, property.Type, elementType, "value");
                }
                else if (_typeResolver.NeedsWrapping(property.Type))
                {
                    var bridgeInfo = GetBridgeInfo(property.Type);
                    builder.AppendLine("var value = _instance." + property.Name + ";");
                    builder.AppendLine($"return value != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(value) : null!;");
                }
                else
                {
                    builder.AppendLine($"return _instance.{property.Name};");
                }
                
                builder.CloseBlock();
            }
            
            if (property.HasSetter)
            {
                builder.OpenBlock("set");
                
                // Check if property type is a dictionary with values that need unwrapping
                if (IsDictionary(property.Type, out var keyType, out var valueType) && _typeResolver.NeedsWrapping(valueType))
                {
                    builder.AppendLine("if (value == null)");
                    builder.AppendLine("{");
                    builder.AppendLine($"    _instance.{property.Name} = null;");
                    builder.AppendLine("}");
                    builder.AppendLine("else");
                    builder.AppendLine("{");
                    
                    // Convert bridge dictionary back to original type
                    var valueBridgeInfo = GetBridgeInfo(valueType);
                    var originalKeyType = keyType.ToDisplayString();
                    var originalValueType = valueType.ToDisplayString();
                    
                    // Ensure types are globally qualified (but not for built-in types)
                    if (!originalKeyType.StartsWith("global::") && !IsBuiltInType(originalKeyType))
                        originalKeyType = $"global::{originalKeyType}";
                    if (!originalValueType.StartsWith("global::") && !IsBuiltInType(originalValueType))
                        originalValueType = $"global::{originalValueType}";
                    
                    builder.AppendLine($"    var result = new global::System.Collections.Generic.Dictionary<{originalKeyType}, {originalValueType}>();");
                    builder.AppendLine($"    foreach (var kvp in value)");
                    builder.AppendLine($"    {{");
                    builder.AppendLine($"        var bridgedValue = kvp.Value as global::{valueBridgeInfo.BridgeFullName};");
                    builder.AppendLine($"        result[kvp.Key] = bridgedValue?._instance;");
                    builder.AppendLine($"    }}");
                    builder.AppendLine($"    _instance.{property.Name} = result;");
                    
                    builder.AppendLine("}");
                }
                // Check if property type is a collection with elements that need unwrapping
                else if (IsCollection(property.Type, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    builder.AppendLine("if (value == null)");
                    builder.AppendLine("{");
                    builder.AppendLine($"    _instance.{property.Name} = null;");
                    builder.AppendLine("}");
                    builder.AppendLine("else");
                    builder.AppendLine("{");
                    
                    // Convert bridge collection back to original type
                    builder.AppendLine($"    var __convertFunc = new global::System.Func<dynamic, dynamic>(item => item?._instance);");
                    builder.AppendLine($"    var enumerable = (global::System.Collections.IEnumerable)value;");
                    
                    if (property.Type is IArrayTypeSymbol)
                    {
                        builder.AppendLine($"    _instance.{property.Name} = enumerable.Cast<dynamic>().Select(__convertFunc).ToArray();");
                    }
                    else if (IsListType(property.Type))
                    {
                        builder.AppendLine($"    _instance.{property.Name} = enumerable.Cast<dynamic>().Select(__convertFunc).ToList();");
                    }
                    else
                    {
                        builder.AppendLine($"    _instance.{property.Name} = enumerable.Cast<dynamic>().Select(__convertFunc);");
                    }
                    
                    builder.AppendLine("}");
                }
                else if (_typeResolver.NeedsWrapping(property.Type))
                {
                    builder.AppendLine($"_instance.{property.Name} = value?._instance;");
                }
                else
                {
                    builder.AppendLine($"_instance.{property.Name} = value;");
                }
                
                builder.CloseBlock();
            }
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateMethod(CodeBuilder builder, MethodModel method)
        {
            // Validate method for AppDomain compatibility
            if (_context.HasValue)
            {
                var diagnostics = _methodValidator.ValidateMethod(method, method.Symbol, method.Symbol.Locations.FirstOrDefault() ?? Location.None);
                foreach (var diagnostic in diagnostics)
                {
                    _context.Value.ReportDiagnostic(diagnostic);
                }
            }
            
            // Check if method is async (returns Task or Task<T>)
            var isAsync = IsTaskType(method.ReturnType, out var taskResultType);
            
            if (isAsync)
            {
                // Generate async wrapper method that calls synchronous wrapper via Task.Run
                GenerateAsyncBridgeMethod(builder, method, taskResultType);
                // Also generate the internal synchronous wrapper method
                GenerateSyncWrapperMethod(builder, method, taskResultType);
            }
            else
            {
                // Generate normal synchronous method
                GenerateNormalMethod(builder, method);
            }
        }
        
        private void GenerateAsyncBridgeMethod(CodeBuilder builder, MethodModel method, ITypeSymbol? taskResultType)
        {
            var returnType = _typeResolver.ResolveType(method.ReturnType);
            var parameters = GenerateParameterList(method.Parameters);
            var syncMethodName = $"__DomainBridge_Sync_{method.Name}";
            
            builder.OpenBlock($"public async {returnType} {method.Name}({parameters})");
            
            // Wrap in try-catch for exception handling
            builder.OpenBlock("try");
            
            // Generate the Task.Run call to the sync wrapper
            var args = GenerateArgumentList(method.Parameters);
            var hasCancellationToken = method.Parameters.Any(p => p.Type.Name == "CancellationToken");
            var cancellationTokenParam = hasCancellationToken ? method.Parameters.First(p => p.Type.Name == "CancellationToken").Name : null;
            
            if (taskResultType == null)
            {
                // Task (non-generic)
                if (hasCancellationToken)
                {
                    builder.AppendLine($"await global::System.Threading.Tasks.Task.Run(() => {syncMethodName}({args}), {cancellationTokenParam});");
                }
                else
                {
                    builder.AppendLine($"await global::System.Threading.Tasks.Task.Run(() => {syncMethodName}({args}));");
                }
            }
            else
            {
                // Task<T>
                if (hasCancellationToken)
                {
                    builder.AppendLine($"return await global::System.Threading.Tasks.Task.Run(() => {syncMethodName}({args}), {cancellationTokenParam});");
                }
                else
                {
                    builder.AppendLine($"return await global::System.Threading.Tasks.Task.Run(() => {syncMethodName}({args}));");
                }
            }
            
            builder.CloseBlock(); // try
            
            // Add catch block for non-serializable exceptions
            builder.OpenBlock("catch (global::System.Exception ex) when (!IsSerializableException(ex))");
            builder.AppendLine("// Wrap non-serializable exceptions in a serializable wrapper");
            builder.AppendLine("throw new global::System.InvalidOperationException(");
            builder.AppendLine($"    $\"Exception in method {method.Name}: {{ex.GetType().Name}}: {{ex.Message}}\",");
            builder.AppendLine("    ex.InnerException);");
            builder.CloseBlock(); // catch
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateSyncWrapperMethod(CodeBuilder builder, MethodModel method, ITypeSymbol? taskResultType)
        {
            // This method is public so it can be called across AppDomain boundaries
            var syncMethodName = $"__DomainBridge_Sync_{method.Name}";
            var returnType = taskResultType != null ? _typeResolver.ResolveType(taskResultType) : "void";
            var parameters = GenerateParameterList(method.Parameters);
            
            builder.OpenBlock($"public {returnType} {syncMethodName}({parameters})");
            
            // Wrap in try-catch for exception handling
            builder.OpenBlock("try");
            
            var args = GenerateArgumentList(method.Parameters);
            // Handle ValueTask conversion
            var isValueTask = method.ReturnType is INamedTypeSymbol namedType && 
                             (namedType.Name == "ValueTask" || 
                              (namedType.IsGenericType && namedType.ConstructedFrom?.Name == "ValueTask"));
            
            var methodCall = isValueTask 
                ? $"_instance.{method.Name}({args}).AsTask().ConfigureAwait(false).GetAwaiter().GetResult()"
                : $"_instance.{method.Name}({args}).ConfigureAwait(false).GetAwaiter().GetResult()";
            
            if (taskResultType == null)
            {
                // Task (non-generic) - just call and wait
                builder.AppendLine($"{methodCall};");
            }
            else if (_typeResolver.NeedsWrapping(taskResultType))
            {
                // Task<T> where T needs wrapping
                builder.AppendLine($"var result = {methodCall};");
                
                // Handle collections specially
                if (IsCollection(taskResultType, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    GenerateCollectionReturn(builder, taskResultType, elementType, "result");
                }
                else
                {
                    // Single object wrapping
                    var bridgeInfo = GetBridgeInfo(taskResultType);
                    builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
                }
            }
            else
            {
                // Task<T> where T doesn't need wrapping
                builder.AppendLine($"return {methodCall};");
            }
            
            builder.CloseBlock(); // try
            
            // Add catch block for non-serializable exceptions
            builder.OpenBlock("catch (global::System.Exception ex) when (!IsSerializableException(ex))");
            builder.AppendLine("// Wrap non-serializable exceptions in a serializable wrapper");
            builder.AppendLine("throw new global::System.InvalidOperationException(");
            builder.AppendLine($"    $\"Exception in method {syncMethodName}: {{ex.GetType().Name}}: {{ex.Message}}\",");
            builder.AppendLine("    ex.InnerException);");
            builder.CloseBlock(); // catch
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateNormalMethod(CodeBuilder builder, MethodModel method)
        {
            var returnType = _typeResolver.ResolveType(method.ReturnType);
            var parameters = GenerateParameterList(method.Parameters);
            
            builder.OpenBlock($"public {returnType} {method.Name}({parameters})");
            
            // Generate method call with exception wrapping
            var args = GenerateArgumentList(method.Parameters);
            var methodCall = $"_instance.{method.Name}({args})";
            
            // Wrap in try-catch for exception handling
            builder.OpenBlock("try");
            
            if (method.ReturnType.SpecialType == SpecialType.System_Void)
            {
                builder.AppendLine($"{methodCall};");
            }
            else
            {
                GenerateReturnStatement(builder, method.ReturnType, methodCall);
            }
            
            builder.CloseBlock(); // try
            
            // Add catch block for non-serializable exceptions
            builder.OpenBlock("catch (global::System.Exception ex) when (!IsSerializableException(ex))");
            builder.AppendLine("// Wrap non-serializable exceptions in a serializable wrapper");
            builder.AppendLine("throw new global::System.InvalidOperationException(");
            builder.AppendLine($"    $\"Exception in method {method.Name}: {{ex.GetType().Name}}: {{ex.Message}}\",");
            builder.AppendLine("    ex.InnerException);");
            builder.CloseBlock(); // catch
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateReturnStatement(CodeBuilder builder, ITypeSymbol returnType, string methodCall)
        {
            // Check if return type is a dictionary that might need wrapping
            if (IsDictionary(returnType, out var keyType, out var valueType))
            {
                if (_typeResolver.NeedsWrapping(valueType))
                {
                    // Dictionary with values that need wrapping
                    GenerateDictionaryReturn(builder, returnType, keyType, valueType, methodCall);
                }
                else
                {
                    // Dictionary with values that don't need wrapping
                    builder.AppendLine($"return {methodCall};");
                }
            }
            // Check if return type is a collection that might need wrapping
            else if (IsCollection(returnType, out var elementType))
            {
                if (_typeResolver.NeedsWrapping(elementType))
                {
                    // Collection with elements that need wrapping
                    GenerateCollectionReturn(builder, returnType, elementType, methodCall);
                }
                else
                {
                    // Collection with elements that don't need wrapping
                    builder.AppendLine($"return {methodCall};");
                }
            }
            else if (_typeResolver.NeedsWrapping(returnType))
            {
                // Single object wrapping
                var bridgeInfo = GetBridgeInfo(returnType);
                builder.AppendLine($"var result = {methodCall};");
                builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
            }
            else
            {
                builder.AppendLine($"return {methodCall};");
            }
        }
        
        private void GenerateCollectionReturn(
            CodeBuilder builder, 
            ITypeSymbol collectionType, 
            ITypeSymbol elementType,
            string methodCall)
        {
            var bridgeInfo = GetBridgeInfo(elementType);
            
            // Check if we already have the result variable
            if (!methodCall.Equals("result", StringComparison.Ordinal) && !methodCall.Equals("value", StringComparison.Ordinal))
            {
                builder.AppendLine($"var result = {methodCall};");
                methodCall = "result";
            }
            
            builder.AppendLine($"if ({methodCall} == null) return null!;");
            
            // Create a function variable to avoid lambda with dynamic
            var funcName = $"__bridgeFunc_{elementType.Name}";
            builder.AppendLine($"var {funcName} = new global::System.Func<dynamic, global::{bridgeInfo.BridgeFullName}>(item => ");
            builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null!);");
            
            // Cast to IEnumerable first to ensure Cast method is available
            builder.AppendLine($"var enumerable = (global::System.Collections.IEnumerable){methodCall};");
            
            // Determine the collection type and generate appropriate wrapping
            if (collectionType is IArrayTypeSymbol)
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToArray();");
            }
            else if (IsListType(collectionType))
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToList();");
            }
            else
            {
                // Default to IEnumerable
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName});");
            }
        }
        
        private void GenerateDictionaryReturn(
            CodeBuilder builder,
            ITypeSymbol dictionaryType,
            ITypeSymbol keyType,
            ITypeSymbol valueType,
            string methodCall)
        {
            var valueBridgeInfo = GetBridgeInfo(valueType);
            
            // Check if we already have the result variable
            if (!methodCall.Equals("result", StringComparison.Ordinal) && !methodCall.Equals("value", StringComparison.Ordinal))
            {
                builder.AppendLine($"var dict = {methodCall};");
                methodCall = "dict";
            }
            
            builder.AppendLine($"if ({methodCall} == null) return null!;");
            
            // Create the wrapped dictionary
            var keyTypeName = _typeResolver.ResolveType(keyType);
            var valueTypeName = _typeResolver.ResolveType(valueType);
            
            builder.AppendLine($"var result = new global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>();");
            builder.AppendLine($"foreach (var kvp in {methodCall})");
            builder.AppendLine("{");
            builder.AppendLine($"    var wrappedValue = kvp.Value != null ? global::{valueBridgeInfo.BridgeFullName}.GetOrCreate(kvp.Value) : null!;");
            builder.AppendLine($"    result[kvp.Key] = wrappedValue;");
            builder.AppendLine("}");
            builder.AppendLine("return result;");
        }
        
        private string GenerateParameterList(IList<ParameterModel> parameters)
        {
            return string.Join(", ", parameters.Select(p =>
            {
                var paramType = _typeResolver.ResolveType(p.Type);
                var defaultValue = p.HasDefaultValue ? $" = {FormatDefaultValue(p.DefaultValue)}" : "";
                return $"{paramType} {EscapeIdentifier(p.Name)}{defaultValue}";
            }));
        }
        
        private string GenerateArgumentList(IList<ParameterModel> parameters)
        {
            return string.Join(", ", parameters.Select(p =>
            {
                if (_typeResolver.NeedsWrapping(p.Type))
                {
                    return $"{EscapeIdentifier(p.Name)}?._instance";
                }
                return EscapeIdentifier(p.Name);
            }));
        }
        
        private void GenerateEvent(CodeBuilder builder, EventModel evt)
        {
            var eventType = _typeResolver.ResolveType(evt.Type);
            builder.AppendLine($"public event {eventType} {evt.Name}");
            builder.OpenBlock("");
            builder.AppendLine($"add {{ _instance.{evt.Name} += value; }}");
            builder.AppendLine($"remove {{ _instance.{evt.Name} -= value; }}");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateEnsureIsolatedDomainMethod(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel,
            AttributeConfiguration? config)
        {
            builder.OpenBlock("private static void EnsureIsolatedDomain(global::DomainBridge.DomainConfiguration? config = null)");
            builder.OpenBlock("if (_isolatedDomain == null)");
            builder.OpenBlock("lock (_lock)");
            builder.OpenBlock("if (_isolatedDomain == null)");
            
            builder.AppendLine("config = config ?? new global::DomainBridge.DomainConfiguration();");
            builder.AppendLine($"config.TargetAssembly = typeof({typeModel.Symbol.ToDisplayString()}).Assembly.FullName;");
            
            if (config != null)
            {
                if (!string.IsNullOrEmpty(config.PrivateBinPath))
                    builder.AppendLine($"config.PrivateBinPath = config.PrivateBinPath ?? @\"{config.PrivateBinPath}\";");
                if (!string.IsNullOrEmpty(config.ApplicationBase))
                    builder.AppendLine($"config.ApplicationBase = config.ApplicationBase ?? @\"{config.ApplicationBase}\";");
                if (!string.IsNullOrEmpty(config.ConfigurationFile))
                    builder.AppendLine($"config.ConfigurationFile = config.ConfigurationFile ?? @\"{config.ConfigurationFile}\";");
                if (config.EnableShadowCopy)
                    builder.AppendLine("config.EnableShadowCopy = true;");
            }
            
            builder.AppendLine();
            builder.AppendLine("var setup = new global::System.AppDomainSetup");
            builder.AppendLine("{");
            builder.AppendLine("    ApplicationBase = config.ApplicationBase ?? global::System.AppDomain.CurrentDomain.BaseDirectory,");
            builder.AppendLine("    PrivateBinPath = config.PrivateBinPath,");
            builder.AppendLine("    ConfigurationFile = config.ConfigurationFile");
            builder.AppendLine("};");
            builder.AppendLine();
            builder.AppendLine($"var domainName = $\"{bridgeInfo.BridgeClassName}_IsolatedDomain_{{System.Guid.NewGuid():N}}\";");
            builder.AppendLine("_isolatedDomain = global::System.AppDomain.CreateDomain(domainName, null, setup);");
            
            builder.CloseBlock();
            builder.CloseBlock();
            builder.CloseBlock();
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateGetOrCreateRemoteBridgeMethod(CodeBuilder builder, BridgeTypeInfo bridgeInfo)
        {
            builder.OpenBlock($"private static {bridgeInfo.BridgeClassName} GetOrCreateRemoteBridge()");
            builder.OpenBlock("if (_remoteProxy == null)");
            builder.OpenBlock("lock (_lock)");
            builder.OpenBlock("if (_remoteProxy == null)");
            builder.AppendLine("EnsureIsolatedDomain();");
            builder.AppendLine();
            builder.AppendLine($"var bridgeType = typeof({bridgeInfo.BridgeClassName});");
            builder.AppendLine("_remoteProxy = _isolatedDomain!.CreateInstanceAndUnwrap(");
            builder.AppendLine("    bridgeType.Assembly.FullName,");
            builder.AppendLine("    bridgeType.FullName);");
            builder.CloseBlock();
            builder.CloseBlock();
            builder.CloseBlock();
            builder.AppendLine($"return ({bridgeInfo.BridgeClassName})_remoteProxy;");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateStaticInstanceProperty(CodeBuilder builder, BridgeTypeInfo bridgeInfo, TypeModel typeModel)
        {
            // Only generate for explicitly marked types that might have static Instance properties
            if (!bridgeInfo.IsExplicitlyMarked)
                return;
                
            // Check if the target type has a static Instance property
            var targetType = typeModel.Symbol;
            var staticInstanceProperty = targetType.GetMembers("Instance")
                .OfType<IPropertySymbol>()
                .FirstOrDefault(p => p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null);
                
            if (staticInstanceProperty != null)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Gets a bridge around the static Instance property of {targetType.Name}");
                builder.AppendLine("/// </summary>");
                builder.OpenBlock($"public static {bridgeInfo.BridgeClassName} Instance");
                builder.OpenBlock("get");
                builder.AppendLine($"var targetInstance = {targetType.ToDisplayString()}.Instance;");
                builder.AppendLine($"return GetOrCreate(targetInstance);");
                builder.CloseBlock();
                builder.CloseBlock();
                builder.AppendLine();
            }
        }
        
        private void GenerateHelperMethods(CodeBuilder builder)
        {
            // Generate IsSerializableException helper method
            builder.AppendLine("/// <summary>");
            builder.AppendLine("/// Checks if an exception can be properly serialized across AppDomain boundaries");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock("private static bool IsSerializableException(global::System.Exception ex)");
            builder.AppendLine("if (ex == null) return true;");
            builder.AppendLine();
            builder.AppendLine("// Check if the exception type has the [Serializable] attribute");
            builder.AppendLine("var exceptionType = ex.GetType();");
            builder.AppendLine("if (!exceptionType.IsSerializable) return false;");
            builder.AppendLine();
            builder.AppendLine("// Check common serializable exception types");
            builder.AppendLine("if (ex is global::System.ArgumentException ||");
            builder.AppendLine("    ex is global::System.InvalidOperationException ||");
            builder.AppendLine("    ex is global::System.NotSupportedException ||");
            builder.AppendLine("    ex is global::System.NotImplementedException ||");
            builder.AppendLine("    ex is global::System.UnauthorizedAccessException ||");
            builder.AppendLine("    ex is global::System.TimeoutException ||");
            builder.AppendLine("    ex is global::System.ApplicationException ||");
            builder.AppendLine("    ex is global::System.SystemException)");
            builder.AppendLine("    return true;");
            builder.AppendLine();
            builder.AppendLine("// For other exception types, try to determine if they're serializable");
            builder.AppendLine("// by checking if they have a serialization constructor");
            builder.AppendLine("try");
            builder.AppendLine("{");
            builder.AppendLine("    var constructor = exceptionType.GetConstructor(");
            builder.AppendLine("        global::System.Reflection.BindingFlags.NonPublic | global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance,");
            builder.AppendLine("        null,");
            builder.AppendLine("        new[] { typeof(global::System.Runtime.Serialization.SerializationInfo), typeof(global::System.Runtime.Serialization.StreamingContext) },");
            builder.AppendLine("        null);");
            builder.AppendLine("    return constructor != null;");
            builder.AppendLine("}");
            builder.AppendLine("catch");
            builder.AppendLine("{");
            builder.AppendLine("    return false;");
            builder.AppendLine("}");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateDisposalMethod(CodeBuilder builder, BridgeTypeInfo bridgeInfo, TypeModel typeModel)
        {
            if (bridgeInfo.IsExplicitlyMarked)
            {
                builder.OpenBlock("public static void UnloadDomain()");
                builder.OpenBlock("lock (_lock)");
                builder.OpenBlock("if (_isolatedDomain != null)");
                builder.OpenBlock("try");
                builder.AppendLine("global::System.AppDomain.Unload(_isolatedDomain);");
                builder.CloseBlock();
                builder.OpenBlock("catch (global::System.Exception ex)");
                builder.AppendLine("global::System.Diagnostics.Debug.WriteLine($\"Failed to unload domain: {ex.Message}\");");
                builder.CloseBlock();
                builder.OpenBlock("finally");
                builder.AppendLine("_isolatedDomain = null;");
                builder.AppendLine("_remoteProxy = null;");
                builder.CloseBlock();
                builder.CloseBlock();
                builder.CloseBlock();
                builder.CloseBlock();
            }
        }
        
        private BridgeTypeInfo GetBridgeInfo(ITypeSymbol type)
        {
            if (_typeResolver.TryGetBridgeInfo(type, out var info) && info != null)
                return info;
                
            throw new InvalidOperationException($"No bridge info found for type {type}");
        }
        
        private bool IsCollection(ITypeSymbol type, out ITypeSymbol elementType)
        {
            elementType = null!;
            
            if (type is IArrayTypeSymbol arrayType)
            {
                elementType = arrayType.ElementType;
                return true;
            }
            
            if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                if (name == "List" || name == "IList" || name == "IEnumerable" || name == "ICollection")
                {
                    elementType = namedType.TypeArguments.FirstOrDefault() ?? throw new InvalidOperationException();
                    return true;
                }
            }
            
            return false;
        }
        
        private bool IsDictionary(ITypeSymbol type, out ITypeSymbol keyType, out ITypeSymbol valueType)
        {
            keyType = null!;
            valueType = null!;
            
            if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                if (name == "Dictionary" || name == "IDictionary")
                {
                    if (namedType.TypeArguments.Length == 2)
                    {
                        keyType = namedType.TypeArguments[0];
                        valueType = namedType.TypeArguments[1];
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        private bool IsListType(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                return name == "List" || name == "IList";
            }
            return false;
        }
        
        private bool IsTaskType(ITypeSymbol type, out ITypeSymbol? taskResultType)
        {
            taskResultType = null;
            
            if (type is INamedTypeSymbol namedType)
            {
                var fullName = namedType.ToDisplayString();
                
                // Check for Task (non-generic)
                if (fullName == "System.Threading.Tasks.Task")
                {
                    return true;
                }
                
                // Check for Task<T>
                if (namedType.IsGenericType && namedType.ConstructedFrom?.Name == "Task")
                {
                    taskResultType = namedType.TypeArguments.FirstOrDefault();
                    return true;
                }
                
                // Check for ValueTask (non-generic)
                if (fullName == "System.Threading.Tasks.ValueTask")
                {
                    return true;
                }
                
                // Check for ValueTask<T>
                if (namedType.IsGenericType && namedType.ConstructedFrom?.Name == "ValueTask")
                {
                    taskResultType = namedType.TypeArguments.FirstOrDefault();
                    return true;
                }
            }
            
            return false;
        }
        
        private void GenerateAsyncReturnStatement(
            CodeBuilder builder, 
            ITypeSymbol returnType, 
            ITypeSymbol? taskResultType, 
            string methodCall)
        {
            // For Task (non-generic), just await the call
            if (taskResultType == null)
            {
                builder.AppendLine($"await {methodCall};");
                return;
            }
            
            // For Task<T>, we need to await and potentially wrap the result
            if (_typeResolver.NeedsWrapping(taskResultType))
            {
                // Handle collections specially
                if (IsCollection(taskResultType, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    builder.AppendLine($"var result = await {methodCall};");
                    GenerateCollectionReturnForAsync(builder, taskResultType, elementType);
                }
                else
                {
                    // Single object wrapping
                    var bridgeInfo = GetBridgeInfo(taskResultType);
                    builder.AppendLine($"var result = await {methodCall};");
                    builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
                }
            }
            else
            {
                builder.AppendLine($"return await {methodCall};");
            }
        }
        
        private void GenerateCollectionReturnForAsync(
            CodeBuilder builder, 
            ITypeSymbol collectionType, 
            ITypeSymbol elementType)
        {
            var bridgeInfo = GetBridgeInfo(elementType);
            builder.AppendLine("if (result == null) return null!;");
            
            // Create a function variable to avoid lambda with dynamic
            var funcName = $"__bridgeFunc_{elementType.Name}";
            builder.AppendLine($"var {funcName} = new global::System.Func<dynamic, global::{bridgeInfo.BridgeFullName}>(item => ");
            builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null!);");
            
            // Cast to IEnumerable first to ensure Cast method is available
            builder.AppendLine($"var enumerable = (global::System.Collections.IEnumerable)result;");
            
            // Determine the collection type and generate appropriate wrapping
            if (collectionType is IArrayTypeSymbol)
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToArray();");
            }
            else if (IsListType(collectionType))
            {
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName}).ToList();");
            }
            else
            {
                // Default to IEnumerable
                builder.AppendLine($"return enumerable.Cast<dynamic>().Select({funcName});");
            }
        }
        
        private string FormatDefaultValue(object? value)
        {
            if (value == null) return "null";
            if (value is string str) return $"@\"{str.Replace("\"", "\"\"")}\"";
            if (value is bool b) return b ? "true" : "false";
            return value.ToString() ?? "null";
        }
        
        private bool IsBuiltInType(string typeName)
        {
            // Check for common built-in types that don't need global:: prefix
            return typeName == "string" || 
                   typeName == "int" || 
                   typeName == "long" || 
                   typeName == "double" || 
                   typeName == "float" || 
                   typeName == "bool" || 
                   typeName == "byte" || 
                   typeName == "short" || 
                   typeName == "decimal" || 
                   typeName == "char" ||
                   typeName == "object" ||
                   typeName == "dynamic";
        }
        
        private string EscapeIdentifier(string identifier)
        {
            var keywords = new HashSet<string>
            {
                "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
                "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum",
                "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto",
                "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace",
                "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
                "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
                "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked",
                "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
            };
            
            return keywords.Contains(identifier) ? $"@{identifier}" : identifier;
        }
    }
}