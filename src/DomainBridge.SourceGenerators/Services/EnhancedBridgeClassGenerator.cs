using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using DomainBridge.SourceGenerators.Models;

namespace DomainBridge.SourceGenerators.Services
{
    /// <summary>
    /// Enhanced bridge class generator that handles automatic type resolution and wrapping
    /// </summary>
    internal sealed class EnhancedBridgeClassGenerator
    {
        private readonly BridgeTypeResolver _typeResolver;
        private readonly TypeAnalyzer _typeAnalyzer;
        private readonly MethodValidator _methodValidator;
        private GeneratorExecutionContext? _context;
        
        public EnhancedBridgeClassGenerator(BridgeTypeResolver typeResolver, TypeAnalyzer typeAnalyzer)
        {
            _typeResolver = typeResolver ?? throw new ArgumentNullException(nameof(typeResolver));
            _typeAnalyzer = typeAnalyzer ?? throw new ArgumentNullException(nameof(typeAnalyzer));
            _methodValidator = new MethodValidator();
        }
        
        public string GenerateBridgeClass(
            BridgeTypeInfo bridgeInfo,
            INamedTypeSymbol targetType,
            AttributeConfiguration? config = null,
            GeneratorExecutionContext? context = null)
        {
            _context = context;
            var typeModel = _typeAnalyzer.AnalyzeType(targetType);
            var builder = new CodeBuilder();
            
            GenerateFileHeader(builder);
            
            // For explicitly marked partial bridges, use the original namespace
            var namespaceToUse = bridgeInfo.IsExplicitlyMarked 
                ? targetType.ContainingNamespace.ToDisplayString()
                : bridgeInfo.BridgeNamespace;
            
            builder.AppendLine($"namespace {namespaceToUse}");
            builder.OpenBlock("");
            
            GenerateBridgeClass(builder, bridgeInfo, typeModel, config);
            
            builder.CloseBlock();
            
            return builder.ToString();
        }
        
        private void GenerateFileHeader(CodeBuilder builder)
        {
            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using System.Linq;");
            builder.AppendLine("using System.Collections.Concurrent;");
            builder.AppendLine("using DomainBridge;");
            builder.AppendLine("using DomainBridge.Runtime;");
            builder.AppendLine();
        }
        
        private void GenerateBridgeClass(
            CodeBuilder builder, 
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel, 
            AttributeConfiguration? config)
        {
            // Generate class declaration
            var classDeclaration = bridgeInfo.IsExplicitlyMarked
                ? $"public partial class {bridgeInfo.BridgeClassName} : global::System.MarshalByRefObject"
                : $"public sealed class {bridgeInfo.BridgeClassName} : global::System.MarshalByRefObject";
                
            // Add interfaces
            if (typeModel.Interfaces.Any())
            {
                var interfaceList = string.Join(", ", typeModel.Interfaces.Select(i => 
                    _typeResolver.ResolveType(i)));
                classDeclaration += $", {interfaceList}";
            }
            
            builder.OpenBlock(classDeclaration);
            
            GenerateFields(builder);
            GenerateConstructors(builder, bridgeInfo, typeModel);
            GenerateFactoryMethods(builder, bridgeInfo, typeModel, config);
            GenerateStaticInstanceProperty(builder, bridgeInfo, typeModel);
            GenerateMembers(builder, typeModel);
            GenerateHelperMethods(builder);
            GenerateDisposalMethod(builder, bridgeInfo, typeModel);
            
            builder.CloseBlock();
        }
        
        private void GenerateFields(CodeBuilder builder)
        {
            builder.AppendLine("private static readonly object _lock = new object();");
            builder.AppendLine("private static global::System.AppDomain? _isolatedDomain;");
            builder.AppendLine("private static dynamic? _remoteProxy;");
            builder.AppendLine("internal readonly dynamic _instance;");
            builder.AppendLine();
        }
        
        private void GenerateConstructors(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel)
        {
            // Constructor that takes the wrapped instance
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Wraps an existing instance of {typeModel.FullName}");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock($"public {bridgeInfo.BridgeClassName}(dynamic instance)");
            builder.AppendLine("_instance = instance ?? throw new global::System.ArgumentNullException(nameof(instance));");
            builder.CloseBlock();
            builder.AppendLine();
            
            // Default constructor for explicitly marked types (needed when created in isolated domain)
            if (bridgeInfo.IsExplicitlyMarked)
            {
                builder.OpenBlock($"public {bridgeInfo.BridgeClassName}()");
                builder.AppendLine("// When created in isolated domain, create the target instance directly");
                builder.AppendLine($"var targetType = typeof({typeModel.FullName});");
                builder.AppendLine("var instanceProperty = targetType.GetProperty(\"Instance\", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);");
                builder.OpenBlock("if (instanceProperty != null && instanceProperty.CanRead)");
                builder.AppendLine("_instance = instanceProperty.GetValue(null);");
                builder.CloseBlock();
                builder.OpenBlock("else");
                builder.AppendLine("_instance = Activator.CreateInstance(targetType);");
                builder.CloseBlock();
                builder.CloseBlock();
                builder.AppendLine();
            }
            
            // Static factory method for cached instance creation
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Gets or creates a cached bridge for the given instance");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock($"internal static {bridgeInfo.BridgeClassName} GetOrCreate(dynamic instance)");
            builder.AppendLine("if (instance == null) return null!;");
            builder.AppendLine($"var factory = new global::System.Func<dynamic, {bridgeInfo.BridgeClassName}>(i => new {bridgeInfo.BridgeClassName}(i));");
            builder.AppendLine($"return global::DomainBridge.Runtime.BridgeInstanceCache.GetOrCreate<{bridgeInfo.BridgeClassName}, dynamic>(");
            builder.AppendLine($"    (dynamic)instance, factory);");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateFactoryMethods(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel,
            AttributeConfiguration? config)
        {
            // Generate CreateIsolated method only for explicitly marked types
            if (bridgeInfo.IsExplicitlyMarked)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine("/// Creates an isolated instance in a separate AppDomain");
                builder.AppendLine("/// </summary>");
                builder.OpenBlock($"public static {bridgeInfo.BridgeClassName} CreateIsolated(global::DomainBridge.DomainConfiguration? config = null)");
                builder.AppendLine("EnsureIsolatedDomain(config);");
                builder.AppendLine("return GetOrCreateRemoteBridge();");
                builder.CloseBlock();
                builder.AppendLine();
                
                GenerateEnsureIsolatedDomainMethod(builder, bridgeInfo, typeModel, config);
                GenerateGetOrCreateRemoteBridgeMethod(builder, bridgeInfo);
            }
        }
        
        private void GenerateMembers(CodeBuilder builder, TypeModel typeModel)
        {
            // Generate properties
            foreach (var property in typeModel.Properties.Where(p => !p.IsIgnored))
            {
                GenerateProperty(builder, property);
            }
            
            // Generate methods
            foreach (var method in typeModel.Methods.Where(m => !m.IsIgnored))
            {
                GenerateMethod(builder, method);
            }
            
            // Generate events
            foreach (var evt in typeModel.Events.Where(e => !e.IsIgnored))
            {
                GenerateEvent(builder, evt);
            }
        }
        
        private void GenerateProperty(CodeBuilder builder, PropertyModel property)
        {
            var propertyType = _typeResolver.ResolveType(property.Type);
            
            builder.OpenBlock($"public {propertyType} {property.Name}");
            
            if (property.HasGetter)
            {
                builder.OpenBlock("get");
                
                if (_typeResolver.NeedsWrapping(property.Type))
                {
                    var bridgeInfo = GetBridgeInfo(property.Type);
                    builder.AppendLine("var value = _instance." + property.Name + ";");
                    builder.AppendLine($"return value != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(value) : null!;");
                }
                else
                {
                    builder.AppendLine($"return _instance.{property.Name};");
                }
                
                builder.CloseBlock();
            }
            
            if (property.HasSetter)
            {
                builder.OpenBlock("set");
                
                if (_typeResolver.NeedsWrapping(property.Type))
                {
                    builder.AppendLine($"_instance.{property.Name} = value?._instance;");
                }
                else
                {
                    builder.AppendLine($"_instance.{property.Name} = value;");
                }
                
                builder.CloseBlock();
            }
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateMethod(CodeBuilder builder, MethodModel method)
        {
            // Validate method for AppDomain compatibility
            if (_context.HasValue)
            {
                var diagnostics = _methodValidator.ValidateMethod(method, method.Symbol, method.Symbol.Locations.FirstOrDefault() ?? Location.None);
                foreach (var diagnostic in diagnostics)
                {
                    _context.Value.ReportDiagnostic(diagnostic);
                }
            }
            
            // Check if method is async (returns Task or Task<T>) before resolving types
            var isAsync = IsTaskType(method.ReturnType, out var taskResultType);
            
            // Check if we'll transform the return type before resolving
            var willTransformTaskResult = false;
            if (isAsync && taskResultType != null)
            {
                willTransformTaskResult = _typeResolver.NeedsWrapping(taskResultType);
            }
            
            var returnType = _typeResolver.ResolveType(method.ReturnType);
            var parameters = GenerateParameterList(method.Parameters);
            
            // Determine if we need async modifier
            var needsAsync = isAsync && (taskResultType == null || willTransformTaskResult);
            var asyncModifier = needsAsync ? "async " : "";
            
            builder.OpenBlock($"public {asyncModifier}{returnType} {method.Name}({parameters})");
            
            // Generate method call with exception wrapping
            var args = GenerateArgumentList(method.Parameters);
            var methodCall = $"_instance.{method.Name}({args})";
            
            // Wrap in try-catch for exception handling
            builder.OpenBlock("try");
            
            if (method.ReturnType.SpecialType == SpecialType.System_Void)
            {
                builder.AppendLine($"{methodCall};");
            }
            else if (isAsync && taskResultType != null && willTransformTaskResult)
            {
                // For Task<T> where T needs wrapping, we need special handling
                var bridgeInfo = GetBridgeInfo(taskResultType);
                builder.AppendLine($"var result = await {methodCall};");
                builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
            }
            else if (isAsync && taskResultType == null)
            {
                // For Task (non-generic), just await
                builder.AppendLine($"await {methodCall};");
            }
            else if (isAsync)
            {
                // For Task<T> where T doesn't need wrapping
                builder.AppendLine($"return {methodCall};");
            }
            else
            {
                GenerateReturnStatement(builder, method.ReturnType, methodCall);
            }
            
            builder.CloseBlock(); // try
            
            // Add catch block for non-serializable exceptions
            builder.OpenBlock("catch (global::System.Exception ex) when (!IsSerializableException(ex))");
            builder.AppendLine("// Wrap non-serializable exceptions in a serializable wrapper");
            builder.AppendLine("throw new global::System.InvalidOperationException(");
            builder.AppendLine($"    $\"Exception in method {method.Name}: {{ex.GetType().Name}}: {{ex.Message}}\",");
            builder.AppendLine("    ex.InnerException);");
            builder.CloseBlock(); // catch
            
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateReturnStatement(CodeBuilder builder, ITypeSymbol returnType, string methodCall)
        {
            // Check if return type needs wrapping
            if (_typeResolver.NeedsWrapping(returnType))
            {
                // Handle collections specially
                if (IsCollection(returnType, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    GenerateCollectionReturn(builder, returnType, elementType, methodCall);
                }
                else
                {
                    // Single object wrapping
                    var bridgeInfo = GetBridgeInfo(returnType);
                    builder.AppendLine($"var result = {methodCall};");
                    builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
                }
            }
            else
            {
                builder.AppendLine($"return {methodCall};");
            }
        }
        
        private void GenerateCollectionReturn(
            CodeBuilder builder, 
            ITypeSymbol collectionType, 
            ITypeSymbol elementType,
            string methodCall)
        {
            var bridgeInfo = GetBridgeInfo(elementType);
            builder.AppendLine($"var result = {methodCall};");
            builder.AppendLine("if (result == null) return null!;");
            
            // Determine the collection type and generate appropriate wrapping
            if (collectionType is IArrayTypeSymbol)
            {
                builder.AppendLine($"return result.Cast<dynamic>().Select(item => ");
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null)");
                builder.AppendLine("    .ToArray();");
            }
            else if (IsListType(collectionType))
            {
                builder.AppendLine($"return result.Cast<dynamic>().Select(item => ");
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null)");
                builder.AppendLine("    .ToList();");
            }
            else
            {
                // Default to IEnumerable
                builder.AppendLine($"return result.Cast<dynamic>().Select(item => ");
                builder.AppendLine($"    item != null ? {bridgeInfo.BridgeFullName}.GetOrCreate(item) : null);");
            }
        }
        
        private string GenerateParameterList(IList<ParameterModel> parameters)
        {
            return string.Join(", ", parameters.Select(p =>
            {
                var paramType = _typeResolver.ResolveType(p.Type);
                var defaultValue = p.HasDefaultValue ? $" = {FormatDefaultValue(p.DefaultValue)}" : "";
                return $"{paramType} {EscapeIdentifier(p.Name)}{defaultValue}";
            }));
        }
        
        private string GenerateArgumentList(IList<ParameterModel> parameters)
        {
            return string.Join(", ", parameters.Select(p =>
            {
                if (_typeResolver.NeedsWrapping(p.Type))
                {
                    return $"{EscapeIdentifier(p.Name)}?._instance";
                }
                return EscapeIdentifier(p.Name);
            }));
        }
        
        private void GenerateEvent(CodeBuilder builder, EventModel evt)
        {
            var eventType = _typeResolver.ResolveType(evt.Type);
            builder.AppendLine($"public event {eventType} {evt.Name}");
            builder.OpenBlock("");
            builder.AppendLine($"add {{ _instance.{evt.Name} += value; }}");
            builder.AppendLine($"remove {{ _instance.{evt.Name} -= value; }}");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateEnsureIsolatedDomainMethod(
            CodeBuilder builder,
            BridgeTypeInfo bridgeInfo,
            TypeModel typeModel,
            AttributeConfiguration? config)
        {
            builder.OpenBlock("private static void EnsureIsolatedDomain(global::DomainBridge.DomainConfiguration? config = null)");
            builder.OpenBlock("if (_isolatedDomain == null)");
            builder.OpenBlock("lock (_lock)");
            builder.OpenBlock("if (_isolatedDomain == null)");
            
            builder.AppendLine("config = config ?? new global::DomainBridge.DomainConfiguration();");
            builder.AppendLine($"config.TargetAssembly = typeof({typeModel.Symbol.ToDisplayString()}).Assembly.FullName;");
            
            if (config != null)
            {
                if (!string.IsNullOrEmpty(config.PrivateBinPath))
                    builder.AppendLine($"config.PrivateBinPath = config.PrivateBinPath ?? @\"{config.PrivateBinPath}\";");
                if (!string.IsNullOrEmpty(config.ApplicationBase))
                    builder.AppendLine($"config.ApplicationBase = config.ApplicationBase ?? @\"{config.ApplicationBase}\";");
                if (!string.IsNullOrEmpty(config.ConfigurationFile))
                    builder.AppendLine($"config.ConfigurationFile = config.ConfigurationFile ?? @\"{config.ConfigurationFile}\";");
                if (config.EnableShadowCopy)
                    builder.AppendLine("config.EnableShadowCopy = true;");
            }
            
            builder.AppendLine();
            builder.AppendLine("var setup = new global::System.AppDomainSetup");
            builder.AppendLine("{");
            builder.AppendLine("    ApplicationBase = config.ApplicationBase ?? global::System.AppDomain.CurrentDomain.BaseDirectory,");
            builder.AppendLine("    PrivateBinPath = config.PrivateBinPath,");
            builder.AppendLine("    ConfigurationFile = config.ConfigurationFile");
            builder.AppendLine("};");
            builder.AppendLine();
            builder.AppendLine($"var domainName = $\"{bridgeInfo.BridgeClassName}_IsolatedDomain_{{System.Guid.NewGuid():N}}\";");
            builder.AppendLine("_isolatedDomain = global::System.AppDomain.CreateDomain(domainName, null, setup);");
            
            builder.CloseBlock();
            builder.CloseBlock();
            builder.CloseBlock();
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateGetOrCreateRemoteBridgeMethod(CodeBuilder builder, BridgeTypeInfo bridgeInfo)
        {
            builder.OpenBlock($"private static {bridgeInfo.BridgeClassName} GetOrCreateRemoteBridge()");
            builder.OpenBlock("if (_remoteProxy == null)");
            builder.OpenBlock("lock (_lock)");
            builder.OpenBlock("if (_remoteProxy == null)");
            builder.AppendLine("EnsureIsolatedDomain();");
            builder.AppendLine();
            builder.AppendLine($"var bridgeType = typeof({bridgeInfo.BridgeClassName});");
            builder.AppendLine("_remoteProxy = _isolatedDomain!.CreateInstanceAndUnwrap(");
            builder.AppendLine("    bridgeType.Assembly.FullName,");
            builder.AppendLine("    bridgeType.FullName);");
            builder.CloseBlock();
            builder.CloseBlock();
            builder.CloseBlock();
            builder.AppendLine($"return ({bridgeInfo.BridgeClassName})_remoteProxy;");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateStaticInstanceProperty(CodeBuilder builder, BridgeTypeInfo bridgeInfo, TypeModel typeModel)
        {
            // Only generate for explicitly marked types that might have static Instance properties
            if (!bridgeInfo.IsExplicitlyMarked)
                return;
                
            // Check if the target type has a static Instance property
            var targetType = typeModel.Symbol;
            var staticInstanceProperty = targetType.GetMembers("Instance")
                .OfType<IPropertySymbol>()
                .FirstOrDefault(p => p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null);
                
            if (staticInstanceProperty != null)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Gets a bridge around the static Instance property of {targetType.Name}");
                builder.AppendLine("/// </summary>");
                builder.OpenBlock($"public static {bridgeInfo.BridgeClassName} Instance");
                builder.OpenBlock("get");
                builder.AppendLine($"var targetInstance = {targetType.ToDisplayString()}.Instance;");
                builder.AppendLine($"return GetOrCreate(targetInstance);");
                builder.CloseBlock();
                builder.CloseBlock();
                builder.AppendLine();
            }
        }
        
        private void GenerateHelperMethods(CodeBuilder builder)
        {
            // Generate IsSerializableException helper method
            builder.AppendLine("/// <summary>");
            builder.AppendLine("/// Checks if an exception can be properly serialized across AppDomain boundaries");
            builder.AppendLine("/// </summary>");
            builder.OpenBlock("private static bool IsSerializableException(global::System.Exception ex)");
            builder.AppendLine("if (ex == null) return true;");
            builder.AppendLine();
            builder.AppendLine("// Check if the exception type has the [Serializable] attribute");
            builder.AppendLine("var exceptionType = ex.GetType();");
            builder.AppendLine("if (!exceptionType.IsSerializable) return false;");
            builder.AppendLine();
            builder.AppendLine("// Check common serializable exception types");
            builder.AppendLine("if (ex is global::System.ArgumentException ||");
            builder.AppendLine("    ex is global::System.InvalidOperationException ||");
            builder.AppendLine("    ex is global::System.NotSupportedException ||");
            builder.AppendLine("    ex is global::System.NotImplementedException ||");
            builder.AppendLine("    ex is global::System.UnauthorizedAccessException ||");
            builder.AppendLine("    ex is global::System.TimeoutException ||");
            builder.AppendLine("    ex is global::System.ApplicationException ||");
            builder.AppendLine("    ex is global::System.SystemException)");
            builder.AppendLine("    return true;");
            builder.AppendLine();
            builder.AppendLine("// For other exception types, try to determine if they're serializable");
            builder.AppendLine("// by checking if they have a serialization constructor");
            builder.AppendLine("try");
            builder.AppendLine("{");
            builder.AppendLine("    var constructor = exceptionType.GetConstructor(");
            builder.AppendLine("        global::System.Reflection.BindingFlags.NonPublic | global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance,");
            builder.AppendLine("        null,");
            builder.AppendLine("        new[] { typeof(global::System.Runtime.Serialization.SerializationInfo), typeof(global::System.Runtime.Serialization.StreamingContext) },");
            builder.AppendLine("        null);");
            builder.AppendLine("    return constructor != null;");
            builder.AppendLine("}");
            builder.AppendLine("catch");
            builder.AppendLine("{");
            builder.AppendLine("    return false;");
            builder.AppendLine("}");
            builder.CloseBlock();
            builder.AppendLine();
        }
        
        private void GenerateDisposalMethod(CodeBuilder builder, BridgeTypeInfo bridgeInfo, TypeModel typeModel)
        {
            if (bridgeInfo.IsExplicitlyMarked)
            {
                builder.OpenBlock("public static void UnloadDomain()");
                builder.OpenBlock("lock (_lock)");
                builder.OpenBlock("if (_isolatedDomain != null)");
                builder.OpenBlock("try");
                builder.AppendLine("global::System.AppDomain.Unload(_isolatedDomain);");
                builder.CloseBlock();
                builder.OpenBlock("catch (global::System.Exception ex)");
                builder.AppendLine("global::System.Diagnostics.Debug.WriteLine($\"Failed to unload domain: {ex.Message}\");");
                builder.CloseBlock();
                builder.OpenBlock("finally");
                builder.AppendLine("_isolatedDomain = null;");
                builder.AppendLine("_remoteProxy = null;");
                builder.CloseBlock();
                builder.CloseBlock();
                builder.CloseBlock();
                builder.CloseBlock();
            }
        }
        
        private BridgeTypeInfo GetBridgeInfo(ITypeSymbol type)
        {
            if (_typeResolver.TryGetBridgeInfo(type, out var info) && info != null)
                return info;
                
            throw new InvalidOperationException($"No bridge info found for type {type}");
        }
        
        private bool IsCollection(ITypeSymbol type, out ITypeSymbol elementType)
        {
            elementType = null!;
            
            if (type is IArrayTypeSymbol arrayType)
            {
                elementType = arrayType.ElementType;
                return true;
            }
            
            if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                if (name == "List" || name == "IList" || name == "IEnumerable" || name == "ICollection")
                {
                    elementType = namedType.TypeArguments.FirstOrDefault() ?? throw new InvalidOperationException();
                    return true;
                }
            }
            
            return false;
        }
        
        private bool IsListType(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                var name = namedType.ConstructedFrom?.Name ?? namedType.Name;
                return name == "List" || name == "IList";
            }
            return false;
        }
        
        private bool IsTaskType(ITypeSymbol type, out ITypeSymbol? taskResultType)
        {
            taskResultType = null;
            
            if (type is INamedTypeSymbol namedType)
            {
                var fullName = namedType.ToDisplayString();
                
                // Check for Task (non-generic)
                if (fullName == "System.Threading.Tasks.Task")
                {
                    return true;
                }
                
                // Check for Task<T>
                if (namedType.IsGenericType && namedType.ConstructedFrom?.Name == "Task")
                {
                    taskResultType = namedType.TypeArguments.FirstOrDefault();
                    return true;
                }
            }
            
            return false;
        }
        
        private void GenerateAsyncReturnStatement(
            CodeBuilder builder, 
            ITypeSymbol returnType, 
            ITypeSymbol? taskResultType, 
            string methodCall)
        {
            // For Task (non-generic), just await the call
            if (taskResultType == null)
            {
                builder.AppendLine($"await {methodCall};");
                return;
            }
            
            // For Task<T>, we need to await and potentially wrap the result
            if (_typeResolver.NeedsWrapping(taskResultType))
            {
                // Handle collections specially
                if (IsCollection(taskResultType, out var elementType) && _typeResolver.NeedsWrapping(elementType))
                {
                    builder.AppendLine($"var result = await {methodCall};");
                    GenerateCollectionReturnForAsync(builder, taskResultType, elementType);
                }
                else
                {
                    // Single object wrapping
                    var bridgeInfo = GetBridgeInfo(taskResultType);
                    builder.AppendLine($"var result = await {methodCall};");
                    builder.AppendLine($"return result != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(result) : null!;");
                }
            }
            else
            {
                builder.AppendLine($"return await {methodCall};");
            }
        }
        
        private void GenerateCollectionReturnForAsync(
            CodeBuilder builder, 
            ITypeSymbol collectionType, 
            ITypeSymbol elementType)
        {
            var bridgeInfo = GetBridgeInfo(elementType);
            builder.AppendLine("if (result == null) return null!;");
            
            // Determine the collection type and generate appropriate wrapping
            if (collectionType is IArrayTypeSymbol)
            {
                builder.AppendLine($"return result.Cast<dynamic>().Select(item => ");
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null)");
                builder.AppendLine("    .ToArray();");
            }
            else if (IsListType(collectionType))
            {
                builder.AppendLine($"return result.Cast<dynamic>().Select(item => ");
                builder.AppendLine($"    item != null ? global::{bridgeInfo.BridgeFullName}.GetOrCreate(item) : null)");
                builder.AppendLine("    .ToList();");
            }
            else
            {
                // Default to IEnumerable
                builder.AppendLine($"return result.Cast<dynamic>().Select(item => ");
                builder.AppendLine($"    item != null ? {bridgeInfo.BridgeFullName}.GetOrCreate(item) : null);");
            }
        }
        
        private string FormatDefaultValue(object? value)
        {
            if (value == null) return "null";
            if (value is string str) return $"@\"{str.Replace("\"", "\"\"")}\"";
            if (value is bool b) return b ? "true" : "false";
            return value.ToString() ?? "null";
        }
        
        private string EscapeIdentifier(string identifier)
        {
            var keywords = new HashSet<string>
            {
                "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
                "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum",
                "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto",
                "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace",
                "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
                "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
                "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked",
                "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
            };
            
            return keywords.Contains(identifier) ? $"@{identifier}" : identifier;
        }
    }
}