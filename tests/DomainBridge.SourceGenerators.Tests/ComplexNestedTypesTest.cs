using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using TUnit.Assertions;
using TUnit.Core;

namespace DomainBridge.SourceGenerators.Tests
{
    public class ComplexNestedTypesTest
    {
        [Test]
        public async Task GeneratesBridgeForDeeplyNestedTypes()
        {
            var source = @"
using DomainBridge;
using System;
using System.Collections.Generic;

namespace TestNamespace
{
    // Deep type hierarchy
    public class Level1
    {
        public Level2 GetLevel2() => new Level2();
        public List<Level2> GetLevel2List() => new List<Level2>();
        public Dictionary<string, Level2> GetLevel2Dict() => new Dictionary<string, Level2>();
    }

    public class Level2
    {
        public Level3 GetLevel3() => new Level3();
        public Level3[] GetLevel3Array() => new Level3[0];
    }

    public class Level3
    {
        public Level4 GetLevel4() => new Level4();
        public IEnumerable<Level4> GetLevel4Enumerable() => new List<Level4>();
    }

    public class Level4
    {
        public Level5 GetLevel5() => new Level5();
        public Task<Level5> GetLevel5Async() => Task.FromResult(new Level5());
    }

    public class Level5
    {
        public string Name { get; set; }
        public int Value { get; set; }
        public NestedClass Nested { get; set; }
        
        public class NestedClass
        {
            public string NestedProperty { get; set; }
        }
    }

    [DomainBridge(typeof(Level1))]
    public partial class Level1Bridge { }
}
";

            var compilation = await TestHelper.CreateCompilation(source);
            var generator = new DomainBridgePatternGenerator();
            var driver = CSharpGeneratorDriver.Create(generator);

            var result = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

            // Check no errors
            await Assert.That(diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error)).IsEmpty();

            // Verify all bridge classes were generated
            var generatedTrees = outputCompilation.SyntaxTrees.Where(t => t.FilePath.EndsWith(".g.cs")).ToList();
            
            // Should have Level1Bridge (explicit) and Level2Bridge through Level5Bridge (auto-discovered)
            // Plus Level5.NestedClassBridge
            await Assert.That(generatedTrees.Count).IsGreaterThanOrEqualTo(6);

            // Verify Level1Bridge was generated correctly
            var level1BridgeTree = generatedTrees.FirstOrDefault(t => t.FilePath.Contains("Level1Bridge"));
            await Assert.That(level1BridgeTree).IsNotNull();
            
            var level1BridgeSource = level1BridgeTree!.ToString();
            await Assert.That(level1BridgeSource).Contains("public partial class Level1Bridge");
            await Assert.That(level1BridgeSource).Contains("public global::TestNamespace.Level2Bridge GetLevel2()");
            await Assert.That(level1BridgeSource).Contains("public global::System.Collections.Generic.List<global::TestNamespace.Level2Bridge> GetLevel2List()");
            await Assert.That(level1BridgeSource).Contains("public global::System.Collections.Generic.Dictionary<string, global::TestNamespace.Level2Bridge> GetLevel2Dict()");

            // Verify auto-generated bridges exist
            var autoGeneratedBridges = generatedTrees.Where(t => !t.FilePath.Contains("Level1Bridge")).ToList();
            await Assert.That(autoGeneratedBridges.Any(t => t.ToString().Contains("public sealed class Level2Bridge"))).IsTrue();
            await Assert.That(autoGeneratedBridges.Any(t => t.ToString().Contains("public sealed class Level3Bridge"))).IsTrue();
            await Assert.That(autoGeneratedBridges.Any(t => t.ToString().Contains("public sealed class Level4Bridge"))).IsTrue();
            await Assert.That(autoGeneratedBridges.Any(t => t.ToString().Contains("public sealed class Level5Bridge"))).IsTrue();

            // Verify nested class bridge
            var nestedClassBridge = autoGeneratedBridges.FirstOrDefault(t => t.ToString().Contains("NestedClassBridge"));
            await Assert.That(nestedClassBridge).IsNotNull();
        }

        [Test]
        public async Task GeneratesBridgeWithAllInterfaceImplementations()
        {
            var source = @"
using DomainBridge;
using System;

namespace TestNamespace
{
    public interface IBase
    {
        string BaseMethod();
        string BaseProperty { get; set; }
        event EventHandler BaseEvent;
    }

    public interface IDerived : IBase
    {
        string DerivedMethod();
        int DerivedProperty { get; }
    }

    public interface IExplicit
    {
        void ExplicitMethod();
        string ExplicitProperty { get; }
    }

    public class ComplexType : IDerived, IExplicit
    {
        // IBase implementation
        public string BaseMethod() => ""base"";
        public string BaseProperty { get; set; }
        public event EventHandler BaseEvent;

        // IDerived implementation
        public string DerivedMethod() => ""derived"";
        public int DerivedProperty => 42;

        // IExplicit implementation (explicit)
        void IExplicit.ExplicitMethod() { }
        string IExplicit.ExplicitProperty => ""explicit"";

        // Own members
        public string OwnMethod() => ""own"";
        public string OwnProperty { get; set; }
    }

    [DomainBridge(typeof(ComplexType))]
    public partial class ComplexTypeBridge { }
}
";

            var compilation = await TestHelper.CreateCompilation(source);
            var generator = new DomainBridgePatternGenerator();
            var driver = CSharpGeneratorDriver.Create(generator);

            var result = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

            // Check no errors
            await Assert.That(diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error)).IsEmpty();

            // Find the generated bridge
            var bridgeTree = outputCompilation.SyntaxTrees.FirstOrDefault(t => t.FilePath.Contains("ComplexTypeBridge"));
            await Assert.That(bridgeTree).IsNotNull();

            var bridgeSource = bridgeTree!.ToString();

            // Verify class declaration includes all interfaces (including base interfaces)
            await Assert.That(bridgeSource).Contains("public partial class ComplexTypeBridge : global::System.MarshalByRefObject, global::System.IDisposable, global::TestNamespace.IDerived, global::TestNamespace.IBase, global::TestNamespace.IExplicit");

            // Verify all interface members are implemented
            // IBase members
            await Assert.That(bridgeSource).Contains("public string BaseMethod()");
            await Assert.That(bridgeSource).Contains("public string BaseProperty");
            await Assert.That(bridgeSource).Contains("public event global::System.EventHandler BaseEvent");

            // IDerived members
            await Assert.That(bridgeSource).Contains("public string DerivedMethod()");
            await Assert.That(bridgeSource).Contains("public int DerivedProperty");

            // IExplicit members (explicit implementation)
            await Assert.That(bridgeSource).Contains("void global::TestNamespace.IExplicit.ExplicitMethod()");
            await Assert.That(bridgeSource).Contains("string global::TestNamespace.IExplicit.ExplicitProperty");

            // Own members
            await Assert.That(bridgeSource).Contains("public string OwnMethod()");
            await Assert.That(bridgeSource).Contains("public string OwnProperty");
        }

        [Test]
        public async Task HandlesTypesWithSameNamesInDifferentNamespaces()
        {
            var source = @"
using DomainBridge;

namespace Namespace1
{
    public class CommonType
    {
        public string Name1 { get; set; }
    }

    public class Container1
    {
        public CommonType GetCommonType() => new CommonType();
    }
}

namespace Namespace2
{
    public class CommonType
    {
        public string Name2 { get; set; }
    }

    public class Container2
    {
        public CommonType GetCommonType() => new CommonType();
    }
}

namespace TestNamespace
{
    [DomainBridge(typeof(Namespace1.Container1))]
    public partial class Container1Bridge { }

    [DomainBridge(typeof(Namespace2.Container2))]
    public partial class Container2Bridge { }
}
";

            var compilation = await TestHelper.CreateCompilation(source);
            var generator = new DomainBridgePatternGenerator();
            var driver = CSharpGeneratorDriver.Create(generator);

            var result = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

            // Check no errors
            await Assert.That(diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error)).IsEmpty();

            // Find generated bridges
            var generatedTrees = outputCompilation.SyntaxTrees.Where(t => t.FilePath.EndsWith(".g.cs")).ToList();

            // Should have bridges for both containers and both CommonType classes
            await Assert.That(generatedTrees.Count).IsGreaterThanOrEqualTo(4);

            // Verify Container1Bridge uses fully qualified names
            var container1Bridge = generatedTrees.FirstOrDefault(t => t.FilePath.Contains("Container1Bridge"));
            await Assert.That(container1Bridge).IsNotNull();
            var container1Source = container1Bridge.ToString();
            await Assert.That(container1Source).Contains("public global::Namespace1.CommonTypeBridge GetCommonType()");

            // Verify Container2Bridge uses fully qualified names
            var container2Bridge = generatedTrees.FirstOrDefault(t => t.FilePath.Contains("Container2Bridge"));
            await Assert.That(container2Bridge).IsNotNull();
            var container2Source = container2Bridge.ToString();
            await Assert.That(container2Source).Contains("public global::Namespace2.CommonTypeBridge GetCommonType()");

            // Verify both CommonType bridges are generated in their respective namespaces
            var commonTypeBridges = generatedTrees.Where(t => t.ToString().Contains("class CommonTypeBridge")).ToList();
            await Assert.That(commonTypeBridges.Count).IsEqualTo(2);
            
            await Assert.That(commonTypeBridges.Any(t => t.ToString().Contains("namespace Namespace1") && t.ToString().Contains("public sealed class CommonTypeBridge"))).IsTrue();
            await Assert.That(commonTypeBridges.Any(t => t.ToString().Contains("namespace Namespace2") && t.ToString().Contains("public sealed class CommonTypeBridge"))).IsTrue();
        }

        [Test]
        public async Task ReportsProperDiagnosticsForUnbridgeableTypes()
        {
            var source = @"
using DomainBridge;
using System;

namespace TestNamespace
{
    // Value type - cannot be bridged
    public struct ValueType
    {
        public string Name { get; set; }
    }

    // Ref struct - cannot be bridged
    public ref struct RefStructType
    {
        public int Value;
    }

    // Class that references unbridgeable types
    public class ProblematicType
    {
        public ValueType GetValue() => new ValueType();
        public unsafe int* GetPointer() => null;
        public Span<int> GetSpan() => Span<int>.Empty;
    }

    [DomainBridge(typeof(ProblematicType))]
    public partial class ProblematicTypeBridge { }
    
    // Try to bridge a value type directly - this should generate a diagnostic
    [DomainBridge(typeof(ValueType))]
    public partial class ValueTypeBridge { }
}
";

            var compilation = await TestHelper.CreateCompilation(source);
            var generator = new DomainBridgePatternGenerator();
            var driver = CSharpGeneratorDriver.Create(generator);

            var result = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

            // Should have diagnostics for unbridgeable types
            var errorDiagnostics = diagnostics.Where(d => d.Id.StartsWith("DBG")).ToList();
            
            // Should have diagnostic for Span<T> return type
            await Assert.That(errorDiagnostics.Any(d => d.Id == "DBG100" && d.GetMessage().Contains("Span"))).IsTrue();
            
            // Should have diagnostic for value type (structs cannot be bridged)
            await Assert.That(errorDiagnostics.Any(d => d.Id == "DBG201" && d.GetMessage().Contains("ValueType"))).IsTrue();
        }

        [Test]
        public async Task HandlesMissingPartialKeyword()
        {
            var source = @"
using DomainBridge;

namespace TestNamespace
{
    public class SimpleType
    {
        public string Name { get; set; }
    }

    // Missing 'partial' keyword
    [DomainBridge(typeof(SimpleType))]
    public class SimpleTypeBridge { }
}
";

            var compilation = await TestHelper.CreateCompilation(source);
            var generator = new DomainBridgePatternGenerator();
            var driver = CSharpGeneratorDriver.Create(generator);

            var result = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

            // Should have diagnostic for missing partial keyword
            var partialDiagnostic = diagnostics.FirstOrDefault(d => d.Id == "DBG205");
            await Assert.That(partialDiagnostic).IsNotNull();
            await Assert.That(partialDiagnostic.GetMessage()).Contains("partial");
        }
    }
}