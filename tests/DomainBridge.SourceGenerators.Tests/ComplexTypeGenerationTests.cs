using System.Threading.Tasks;
using TUnit.Core;
using TUnit.Assertions;

namespace DomainBridge.SourceGenerators.Tests;

public class ComplexTypeGenerationTests
{
    [Test]
    public async Task GeneratesAutoGeneratedReturnTypeBridges()
    {
        var source = """
            using DomainBridge;
            using System.Collections.Generic;
            
            namespace TestNamespace
            {
                [DomainBridge(typeof(ComplexService))]
                public partial class ComplexServiceBridge { }
                
                public class ComplexService
                {
                    public ComplexData GetData() => new ComplexData();
                    public List<ComplexData> GetDataList() => new List<ComplexData>();
                    public Dictionary<string, ComplexData> GetDataDictionary() => new Dictionary<string, ComplexData>();
                }
                
                public class ComplexData
                {
                    public string Name { get; set; } = "";
                    public NestedData Nested { get; set; } = new NestedData();
                }
                
                public class NestedData
                {
                    public int Value { get; set; }
                }
            }
            """;

        var result = TestHelper.RunGenerator(source);
        var output = TestHelper.GetGeneratedOutput(result);
        
        // Verify the ComplexServiceBridge was generated
        await Assert.That(output).Contains("public partial class ComplexServiceBridge : global::System.MarshalByRefObject, global::System.IDisposable");
        
        // Verify methods are generated with correct return types
        // The generator might use actual types instead of dynamic
        await Assert.That(output).Contains("GetData()");
        await Assert.That(output).Contains("GetDataList()");
        await Assert.That(output).Contains("GetDataDictionary()");
        
        // Verify that the generated code includes the necessary members
        await Assert.That(output).Contains("GetData");
        await Assert.That(output).Contains("GetDataList");
        await Assert.That(output).Contains("GetDataDictionary");
    }

    [Test]
    public async Task GeneratesBridgeWithAsyncMethods()
    {
        var source = """
            using DomainBridge;
            using System.Threading.Tasks;
            using System.Threading;
            
            namespace TestNamespace
            {
                [DomainBridge(typeof(AsyncService))]
                public partial class AsyncServiceBridge { }
                
                public class AsyncService
                {
                    public async Task DoWorkAsync()
                    {
                        await Task.Delay(100);
                    }
                    
                    public async Task<string> GetDataAsync(CancellationToken cancellationToken)
                    {
                        await Task.Delay(100, cancellationToken);
                        return "data";
                    }
                    
                    public async ValueTask<int> GetCountAsync()
                    {
                        await Task.Delay(100);
                        return 42;
                    }
                }
            }
            """;

        var result = TestHelper.RunGenerator(source);
        var output = TestHelper.GetGeneratedOutput(result);
        
        // Verify the AsyncServiceBridge was generated
        await Assert.That(output).Contains("public partial class AsyncServiceBridge : global::System.MarshalByRefObject, global::System.IDisposable");
        
        // Verify async methods are generated correctly (with full type names)
        await Assert.That(output).Contains("public async global::System.Threading.Tasks.Task DoWorkAsync()");
        await Assert.That(output).Contains("public async global::System.Threading.Tasks.Task<string> GetDataAsync(global::System.Threading.CancellationToken cancellationToken)");
        await Assert.That(output).Contains("public async global::System.Threading.Tasks.ValueTask<int> GetCountAsync()");
        
        // Verify the async method implementations (using sync wrappers)
        await Assert.That(output).Contains("__DomainBridge_Sync_DoWorkAsync()");
        await Assert.That(output).Contains("__DomainBridge_Sync_GetDataAsync(cancellationToken)");
        await Assert.That(output).Contains("__DomainBridge_Sync_GetCountAsync()");
    }

    [Test]
    public async Task GeneratesBridgeWithGenericCollections()
    {
        var source = """
            using DomainBridge;
            using System.Collections.Generic;
            
            namespace TestNamespace
            {
                [DomainBridge(typeof(CollectionService))]
                public partial class CollectionServiceBridge { }
                
                public class CollectionService
                {
                    public List<string> GetStringList() => new List<string>();
                    public IEnumerable<int> GetNumbers() => new[] { 1, 2, 3 };
                    public HashSet<double> GetUniqueValues() => new HashSet<double>();
                    public string[] GetStringArray() => new string[0];
                    
                    public void ProcessList(List<string> items) { }
                    public void ProcessDictionary(Dictionary<int, string> map) { }
                }
            }
            """;

        var result = TestHelper.RunGenerator(source);
        var output = TestHelper.GetGeneratedOutput(result);
        
        // Verify the CollectionServiceBridge was generated
        await Assert.That(output).Contains("public partial class CollectionServiceBridge : global::System.MarshalByRefObject, global::System.IDisposable");
        
        // Verify methods with generic collection return types (with global:: prefixes)
        await Assert.That(output).Contains("public global::System.Collections.Generic.List<string> GetStringList()");
        await Assert.That(output).Contains("public global::System.Collections.Generic.IEnumerable<int> GetNumbers()");
        await Assert.That(output).Contains("public global::System.Collections.Generic.HashSet<double> GetUniqueValues()");
        await Assert.That(output).Contains("public string[] GetStringArray()");
        
        // Verify methods with generic collection parameters
        await Assert.That(output).Contains("public void ProcessList(global::System.Collections.Generic.List<string> items)");
        await Assert.That(output).Contains("public void ProcessDictionary(global::System.Collections.Generic.Dictionary<int, string> map)");
        
        // Verify the method implementations use _instance
        await Assert.That(output).Contains("_instance.GetStringList()");
        await Assert.That(output).Contains("_instance.GetNumbers()");
        await Assert.That(output).Contains("_instance.ProcessList(items)");
        await Assert.That(output).Contains("_instance.ProcessDictionary(map)");
    }

    [Test]
    public async Task GeneratesBridgeWithNestedTypes()
    {
        var source = """
            using DomainBridge;
            
            namespace TestNamespace
            {
                [DomainBridge(typeof(OuterClass.InnerService))]
                public partial class InnerServiceBridge { }
                
                public class OuterClass
                {
                    public class InnerService
                    {
                        public NestedData GetData() => new NestedData();
                        
                        public class NestedData
                        {
                            public string Value { get; set; } = "";
                        }
                    }
                }
            }
            """;

        var result = TestHelper.RunGenerator(source);
        var output = TestHelper.GetGeneratedOutput(result);
        
        // Verify the InnerServiceBridge was generated using the actual partial class name
        await Assert.That(output).Contains("public partial class InnerServiceBridge : global::System.MarshalByRefObject, global::System.IDisposable");
        
        // Verify the constructor accepts the nested type
        await Assert.That(output).Contains("OuterClass.InnerService");
        
        // Verify method is generated (likely returns dynamic for nested type)
        await Assert.That(output).Contains("GetData()");
        
        // Verify the method implementation uses _instance
        await Assert.That(output).Contains("_instance.GetData()");
    }

    [Test]
    public async Task GeneratesBridgeWithMethodOverloads()
    {
        var source = """
            using DomainBridge;
            
            namespace TestNamespace
            {
                [DomainBridge(typeof(OverloadedService))]
                public partial class OverloadedServiceBridge { }
                
                public class OverloadedService
                {
                    public void Process() { }
                    public void Process(string data) { }
                    public void Process(string data, int count) { }
                    public int Process(int value) => value * 2;
                }
            }
            """;

        var result = TestHelper.RunGenerator(source);
        var output = TestHelper.GetGeneratedOutput(result);
        
        // Verify the OverloadedServiceBridge was generated
        await Assert.That(output).Contains("public partial class OverloadedServiceBridge : global::System.MarshalByRefObject, global::System.IDisposable");
        
        // Verify all method overloads are generated
        await Assert.That(output).Contains("public void Process()");
        await Assert.That(output).Contains("public void Process(string data)");
        await Assert.That(output).Contains("public void Process(string data, int count)");
        await Assert.That(output).Contains("public int Process(int value)");
        
        // Verify the method implementations call the correct overloads using _instance
        await Assert.That(output).Contains("_instance.Process()");
        await Assert.That(output).Contains("_instance.Process(data)");
        await Assert.That(output).Contains("_instance.Process(data, count)");
        await Assert.That(output).Contains("return _instance.Process(value)");
    }
}